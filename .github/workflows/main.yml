# -----------------------------------------------------------------------------------
# Persistent VPS (Full System Backup Edition)
#
# This workflow creates a fully persistent VPS environment by performing a
# comprehensive backup of the entire system state at the end of each session.
# It prioritizes reliability and complete restoration of all installed applications,
# including Aapanel and its services (Apache, PHP, etc.).
#
# Key Features:
# - Full System Backup: Captures the entire filesystem for perfect state restoration.
# - Optimized & Fast: Excludes volatile/large directories to prevent hangs.
# - Uses /mnt Storage: Leverages the larger /mnt drive for backup/restore operations.
# - Aapanel Persistence: Correctly installs on first run and fully restores on subsequent runs.
# - Service Integrity: Robustly restarts all services, including MariaDB and Tailscale.
# -----------------------------------------------------------------------------------

name: Persistent VPS (Full System Backup Edition)

on:
  schedule:
    # Runs automatically every 6 hours to refresh the session.
    - cron: '0 */6 * * *'
  workflow_dispatch:
    # Allows for manual triggering of the workflow from the Actions tab.

env:
  # Configuration for the full system backup.
  # Using /mnt which has significantly more space (~84 GB).
  BACKUP_STORE: /mnt/vps-backups
  BACKUP_NAME: vps-full-backup.tar.gz
  # Rclone remote and path for storing the backup link.
  MEGA_REMOTE: mega:vps-backup

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 350 # Max is 360 minutes (6 hours)
    permissions:
      contents: read
      actions: write # Required to find artifacts from previous runs

    steps:
      - name: '🕸️ Checkout Code'
        uses: actions/checkout@v4

      # ------------------------------------------------------------------
      # Part 1: Initial Setup & Restore Logic
      # ------------------------------------------------------------------

      - name: '🔧 Install Core Tools'
        run: |
          set -euo pipefail
          echo "🌐 Updating package list..."
          sudo apt-get update -qq
          
          echo "☁️ Installing Rclone..."
          curl -fsSL https://rclone.org/install.sh | sudo bash
          
          echo "📦 Installing essential system tools..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            tar gzip openssh-server htop nano vim git net-tools tmate jq curl psmisc screen
            
          echo "✅ All core tools are installed."

      - name: '🛠️ Configure Rclone'
        run: |
          set -euo pipefail
          echo "🔐 Setting up rclone configuration..."
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "❌ ERROR: RCLONE_CONFIG secret is missing!" >&2
            exit 1
          fi
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          echo "✅ Rclone configured successfully."

      - name: '🔍 Check for Backup (Artifact First, then MEGA)'
        id: check_backup
        run: |
          set -euo pipefail
          echo "🔎 Checking for existing backup..."
          ARTIFACT_URL=""
          
          # Method 1: Search recent workflow runs for a backup artifact first. This is faster.
          echo "🔍 Searching recent workflow runs for artifacts..."
          WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows" \
            | jq -r '.workflows[] | select(.name == "Persistent VPS (Full System Backup Edition)") | .id' | head -1)
            
          if [[ -n "$WORKFLOW_ID" && "$WORKFLOW_ID" != "null" ]]; then
            LATEST_RUN_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs?status=success&per_page=3" \
              | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id' | head -1)
              
            if [[ -n "$LATEST_RUN_ID" && "$LATEST_RUN_ID" != "null" ]]; then
              ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/${LATEST_RUN_ID}/artifacts" \
                | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')
                
              if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
                ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
                echo "✅ Found backup in a recent successful run!"
              fi
            fi
          fi

          # Method 2: If no artifact was found, check MEGA for a fallback link.
          if [[ -z "$ARTIFACT_URL" ]]; then
            echo "ℹ️ No recent artifact found. Checking MEGA for a backup link..."
            if rclone ls "${MEGA_REMOTE}/latest_backup_link.txt" >/dev/null 2>&1; then
              ARTIFACT_URL=$(rclone cat "${MEGA_REMOTE}/latest_backup_link.txt")
              echo "✅ Found backup link in MEGA!"
            fi
          fi

          # Final Decision
          if [[ -n "$ARTIFACT_URL" ]]; then
            echo "has_backup=true" >> $GITHUB_OUTPUT
            echo "artifact_url=${ARTIFACT_URL}" >> $GITHUB_OUTPUT
          else
            echo "ℹ️ No backup found anywhere. The system will be set up as a fresh installation."
            echo "has_backup=false" >> $GITHUB_OUTPUT
          fi

      - name: '📥 Download & Restore Full System Backup'
        if: steps.check_backup.outputs.has_backup == 'true'
        run: |
          set -euo pipefail
          echo "📥 Downloading and restoring full system backup..."
          
          # Use /mnt for temporary storage to avoid filling the root disk.
          sudo mkdir -p /mnt/restore
          cd /mnt/restore
          
          echo "Downloading from URL: ${{ steps.check_backup.outputs.artifact_url }}"
          # --- FIX: Run curl with sudo to write to the sudo-created directory ---
          sudo curl --retry 5 --retry-delay 10 -L \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${{ steps.check_backup.outputs.artifact_url }}" \
            -o "backup.zip"
          
          echo "Extracting ZIP archive..."
          # --- FIX: Run unzip with sudo for the same permission reasons ---
          sudo unzip -q backup.zip
          
          if [[ ! -f "${{ env.BACKUP_NAME }}" ]]; then
            echo "❌ Backup file '${{ env.BACKUP_NAME }}' not found after extraction! Listing contents:" >&2
            sudo ls -la
            exit 1
          fi
          
          echo "Restoring system from tarball. This will take some time..."
          # This restores EVERYTHING, ensuring full persistence.
          sudo tar -xzpf "${{ env.BACKUP_NAME }}" -C /
          
          # Clean up the downloaded files
          sudo rm -rf /mnt/restore
          echo "✅ Full system restoration complete."

      # ------------------------------------------------------------------
      # Part 2: Fresh Installation Steps (Conditional)
      # ------------------------------------------------------------------
      
      - name: '📦 Install Docker, MariaDB & Aapanel (Fresh Install Only)'
        if: steps.check_backup.outputs.has_backup == 'false'
        run: |
          set -euo pipefail
          echo "🚀 Performing first-time setup for services..."

          echo "🐳 Installing Docker..."
          curl -fsSL https://get.docker.com | sudo sh

          echo "🗄️ Installing MariaDB..."
          sudo apt-get install -y mariadb-server mariadb-client
          sudo systemctl enable mariadb
          sudo systemctl start mariadb
          
          echo "🔒 Securing MariaDB installation..."
          if [[ -z "${{ secrets.DB_ROOT_PASSWORD || '' }}" ]]; then
             echo "❌ ERROR: DB_ROOT_PASSWORD secret is not set for fresh install!" >&2
             exit 1
          fi
          sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD('${{ secrets.DB_ROOT_PASSWORD }}');"
          sudo mysql -u root -p'${{ secrets.DB_ROOT_PASSWORD }}' -e "FLUSH PRIVILEGES;"

          echo "📥 Downloading and installing Aapanel..."
          curl -fsSL -o /tmp/install.sh "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"
          timeout 900 bash -c "printf 'y\nyes\n' | sudo bash /tmp/install.sh" || echo "⚠️ Aapanel installation timed out or failed. Check logs."
          
          if command -v bt >/dev/null 2>&1; then
            echo "✅ Aapanel installed. Setting default credentials..."
            sleep 5
            echo "Jacky" | sudo bt 6
            echo "spidey" | sudo bt 5
          fi

      - name: '👤 Configure User & Hostname (Fresh Install Only)'
        if: steps.check_backup.outputs.has_backup == 'false'
        run: |
          set -euo pipefail
          echo "👤 Setting up user, password, and hostname..."
          sudo useradd -m -s /bin/bash jacky || echo "User 'jacky' already exists, skipping."
          echo "jacky:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
          sudo usermod -aG sudo,docker jacky
          echo "jacky ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/jacky
          sudo hostnamectl set-hostname github-vps
          echo "127.0.1.1 github-vps" | sudo tee -a /etc/hosts
          echo "✅ System user and hostname configured."

      # ------------------------------------------------------------------
      # Part 3: Service Start & Session (Runs on EVERY execution)
      # ------------------------------------------------------------------

      - name: '🚀 Start All Services (Post-Restore)'
        run: |
          set -euo pipefail
          echo "🔄 Configuring and starting all system services..."
          
          # CRITICAL: Reload systemd to recognize restored service files.
          sudo systemctl daemon-reload
          
          # After a full restore, reinstalling key packages can fix broken links or permissions.
          # apt is idempotent, so it won't harm a fresh install.
          echo "Ensuring essential services are correctly installed and configured..."
          sudo apt-get install -y --reinstall mariadb-server docker-ce
          
          # Fix MariaDB permissions which can be lost during tar extraction.
          if [ -d "/var/lib/mysql" ]; then
            sudo chown -R mysql:mysql /var/lib/mysql
          fi
          
          # Enable and start core services.
          sudo systemctl enable ssh mariadb docker
          sudo systemctl start ssh
          sudo systemctl start mariadb
          sudo systemctl start docker
          
          # Start Aapanel and all services managed by it (e.g., Apache, Nginx, PHP).
          if command -v bt >/dev/null 2>&1; then
            echo "🎛️ Starting Aapanel..."
            sudo bt start
          fi
          
          echo "📊 Final Service Status Check:"
          for service in ssh mariadb docker; do
            if systemctl is-active --quiet $service; then
              echo "  ✅ $service is active."
            else
              echo "  ❌ $service is INACTIVE."
            fi
          done

      - name: '🔗 Configure Remote Access (Tailscale & tmate)'
        run: |
          set -euo pipefail
          echo "🕸️ Setting up Tailscale VPN..."
          
          # If the state file was restored, we don't need a new auth key.
          if [ -f "/var/lib/tailscale/tailscaled.state" ]; then
            echo "✅ Tailscale state restored from backup. Starting service."
            curl -fsSL https://tailscale.com/install.sh | sh
            sudo systemctl enable --now tailscaled
          else
            echo "ℹ️ No Tailscale state found. Performing fresh setup..."
            if [[ -z "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
              echo "❌ ERROR: TAILSCALE_AUTHKEY secret is missing for fresh install!" >&2
              exit 1
            fi
            curl -fsSL https://tailscale.com/install.sh | sh
            sudo systemctl enable --now tailscaled
            sudo tailscale up --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" --hostname=github-vps --reset --accept-routes
          fi
          
          echo "💬 Starting tmate for emergency SSH access..."
          tmate -S /tmp/tmate.sock new-session -d
          tmate -S /tmp/tmate.sock wait tmate-ready
          
          echo "================================================"
          echo "🎉          VPS IS READY FOR CONNECTION         🎉"
          echo "================================================"
          TAILSCALE_IP=$(sudo tailscale ip -4)
          echo "🌐 Tailscale IP: $TAILSCALE_IP"
          echo "🔑 tmate SSH:    $(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')"
          if command -v bt >/dev/null 2>&1; then
            echo ""
            echo "🎛️ Aapanel Panel Details:"
            sudo bt default || true
          fi
          echo "================================================"

      - name: '⏳ Maintain VPS Session'
        run: |
          echo "🖥️ VPS session is running. This step will time out after ~5.5 hours."
          echo "To stop the session gracefully and trigger the backup early, create a file: touch /tmp/stop"
          end_time=$((SECONDS + 19800)) # 5.5 hours
          while [ $SECONDS -lt $end_time ]; do
            if [ -f "/tmp/stop" ]; then
              echo "✅ Graceful shutdown signal detected. Exiting session."
              rm -f "/tmp/stop"
              exit 0
            fi
            sleep 60
          done
          echo "⏰ Session duration reached. Proceeding to backup."

      # ------------------------------------------------------------------
      # Part 4: Full System Backup Creation
      # ------------------------------------------------------------------
      
      - name: '📦 Create Full System Backup'
        if: always()
        run: |
          set -euo pipefail
          echo "📦 Creating comprehensive system backup..."
          sudo mkdir -p "${{ env.BACKUP_STORE }}"
          
          echo "🛑 Stopping services for a clean, consistent backup..."
          if command -v bt >/dev/null 2>&1; then sudo bt stop || true; fi # Ignore errors if not running
          sudo systemctl stop ssh mariadb tailscaled docker || true # Ignore errors
          sleep 5
          
          echo "Creating archive. This may take a while but is much faster now..."
          sudo tar -czpf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" \
            --absolute-names \
            --warning=no-file-changed \
            --directory=/ \
            --exclude="./proc" \
            --exclude="./sys" \
            --exclude="./dev" \
            --exclude="./run" \
            --exclude="./mnt" \
            --exclude="./media" \
            --exclude="./tmp" \
            --exclude="./lost+found" \
            --exclude="./var/lib/docker/overlay2" \
            --exclude="./var/lib/apt/lists" \
            --exclude="./var/cache" \
            --exclude="./var/log" \
            --exclude="${{ env.BACKUP_STORE }}" \
            .
            
          BACKUP_SIZE=$(du -h "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | cut -f1)
          echo "✅ Full system backup created successfully. Size: $BACKUP_SIZE"

      - name: '⬆️ Upload Backup as Artifact'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}
          retention-days: 5 # Keep artifacts for a few days
          if-no-files-found: error

      - name: '🔗 Store Backup Link in MEGA'
        if: always()
        run: |
          set -euo pipefail
          echo "🔗 Storing backup artifact link in MEGA as a fallback..."

          # Wait for artifact to become available via API
          sleep 30 
          for attempt in {1..5}; do
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')
            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
              break
            fi
            echo "⏳ Waiting for artifact API to update ($attempt/5)..."
            sleep 30
          done
          if [[ -z "$ARTIFACT_ID" || "$ARTIFACT_ID" == "null" ]]; then
            echo "❌ Could not get artifact ID after several attempts!"
            exit 1
          fi
          ARTIFACT_LINK="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
          
          # Overwrite the old link in MEGA with the link to the newest backup.
          rclone delete "${MEGA_REMOTE}/latest_backup_link.txt" 2>/dev/null || true
          echo "$ARTIFACT_LINK" | rclone rcat "${MEGA_REMOTE}/latest_backup_link.txt"

          echo "✅ New backup link stored in MEGA."
          # Clean up the large local backup file to save space.
          sudo rm -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}"

      - name: '📋 Final Status Report'
        if: always()
        run: |
          echo "============================================="
          echo "     ✅ VPS SESSION COMPLETE ✅"
          echo "============================================="
          echo "Job Status: ${{ job.status }}"
          echo "Backup Strategy: Full System Backup"
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "The session completed normally and the backup was successful."
          else
            echo "The session failed or was cancelled. A backup was still attempted."
          fi
          echo "============================================="
