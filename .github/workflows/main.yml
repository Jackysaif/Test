# Function to configure Apache with optimizations
          configure_apache() {
            echo "Configuring Apache..."
            
            # Enable essential modules
            APACHE_MODULES=("rewrite" "ssl" "headers" "deflate" "expires" "security2")
            for module in "${APACHE_MODULES[@]}"; do
              sudo a2enmod "$module" 2>/dev/null || echo "Module $module may not be available"
            done
            
            # Create optimized Apache configuration
            cat << 'APACHE_CONFIG' | sudo tee /etc/apache2/conf-available/vps-optimization.conf
# VPS Optimization Configuration
ServerTokens Prod
ServerSignature Off

# Performance settings
Timeout 30
KeepAlive On
MaxKeepAliveRequests 100
KeepAliveTimeout 5

# Prefork MPM optimization for small VPS
<IfModule mpm_prefork_module>
    StartServers 2
    MinSpareServers 2
    MaxSpareServers 5
    MaxRequestWorkers 50
    MaxConnectionsPerChild 1000
</IfModule>

# Security headers
<IfModule mod_headers.c>
    Header always set X-Content-Type-Options nosniff
    Header always set X-Frame-Options SAMEORIGIN
    Header always set X-XSS-Protection "1; mode=block"
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
    Header always set Content-Security-Policy "default-src 'self'"
</IfModule>

# Compression
<IfModule mod_deflate.c>
    AddOutputFilterByType DEFLATE text/html
    AddOutputFilterByType DEFLATE text/css
    AddOutputFilterByType DEFLATE text/javascript
    AddOutputFilterByType DEFLATE text/xml
    AddOutputFilterByType DEFLATE text/plain
    AddOutputFilterByType DEFLATE application/javascript
    AddOutputFilterByType DEFLATE application/x-javascript
    AddOutputFilterByType DEFLATE application/json
    AddOutputFilterByType DEFLATE application/xml
</IfModule>

# Caching
<IfModule mod_expires.c>
    ExpiresActive On
    ExpiresByType text/css "access plus 1 month"
    ExpiresByType application/javascript "access plus 1 month"
    ExpiresByType image/png "access plus 1 year"
    ExpiresByType image/jpg "access plus 1 year"
    ExpiresByType image/jpeg "access plus 1 year"
    ExpiresByType image/gif "access plus 1 year"
    ExpiresByType image/ico "access plus 1 year"
    ExpiresByType image/icon "access plus 1 year"
    ExpiresByType image/x-icon "access plus 1 year"
</IfModule>

# Hide sensitive information
<FilesMatch "\.(htaccess|htpasswd|ini|log|sh|inc|bak)$">
    Require all denied
</FilesMatch>
APACHE_CONFIG
            
            # Enable the configuration
            sudo a2enconf vps-optimization
            
            # Create a default virtual host with PHP info
            cat << 'VHOST_CONFIG' | sudo tee /etc/apache2/sites-available/000-default.conf
<VirtualHost *:80>
    ServerAdmin admin@localhost
    DocumentRoot /var/www/html
    
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
    
    <Directory /var/www/html>
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
    
    # PHP configuration
    <IfModule mod_php.c>
        php_value upload_max_filesize 64M
        php_value post_max_size 64M
        php_value memory_limit 256M
        php_value max_execution_time 300
    </IfModule>
</VirtualHost>
VHOST_CONFIG
            
            # Create a simple index page with system info
            cat << 'INDEX_HTML' | sudo tee /var/www/html/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub VPS - Online</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .status { color: #28a745; font-size: 24px; margin-bottom: 20px; }
        .info { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ GitHub VPS Server</h1>
        <div class="status">‚úÖ Server is online and running!</div>
        
        <div class="info">
            <h3>System Information</h3>
            <p><strong>Server Time:</strong> <span id="serverTime"></span></p>
            <p><strong>Uptime:</strong> Will be shown after system starts</p>
            <p><strong>Web Server:</strong> Apache with PHP</p>
            <p><strong>Database:</strong> MariaDB</p>
        </div>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Security Notice:</strong> This is a temporary VPS instance. 
            Change all default passwords and secure your applications before deploying to production.
        </div>
        
        <div class="info">
            <h3>Available Services</h3>
            <ul>
                <li><a href="/phpinfo.php">PHP Information</a></li>
                <li><a href=":7800" target="_blank">Aapanel (if installed)</a></li>
                <li>SSH Access via Tailscale or tmate</li>
            </ul>
        </div>
    </div>
    
    <script>
        document.getElementById('serverTime').textContent = new Date().toLocaleString();
        setInterval(() => {
            document.getElementById('serverTime').textContent = new Date().toLocaleString();
        }, 1000);
    </script>
</body>
</html>
INDEX_HTML
            
            # Create PHP info page
            cat << 'PHP_INFO' | sudo tee /var/www/html/phpinfo.php
<?php
// Security check - remove in production
if ($_SERVER['SERVER_ADDR'] !== '127.0.0.1' && 
    !in_array($_SERVER['REMOTE_ADDR'], ['127.0.0.1', '::1'])) {
    if (!isset($_GET['allow'])) {
        die('<h1>Access Restricted</h1><p>PHP info is only accessible from localhost or with ?allow parameter.</p>');
    }
}

phpinfo();
?>
PHP_INFO
            
            # Set proper permissions
            sudo chown -R www-data:www-data /var/www/html
            sudo chmod -R 755 /var/www/html
            
            # Test Apache configuration
            if sudo apache2ctl configtest; then
              sudo systemctl enable apache2
              sudo systemctl restart apache2
              echo "‚úÖ Apache configured and started"
            else
              echo "‚ùå Apache configuration test failed"
              return 1
            fi
          }
          
          # Function to configure PHP optimizations
          configure_php() {
            echo "Configuring PHP..."
            
            # Find PHP version
            PHP_VERSION=$(php -r "echo PHP_MAJOR_VERSION.'.'.PHP_MINOR_VERSION;")
            PHP_INI="/etc/php/$PHP_VERSION/apache2/php.ini"
            
            if [[ -f "$PHP_INI" ]]; then
              # Backup original
              sudo cp "$PHP_INI" "$PHP_INI.backup"
              
              # Apply optimizations
              cat << 'PHP_OPTS' | sudo tee -a "$PHP_INI"

; VPS Optimizations
memory_limit = 256M
upload_max_filesize = 64M
post_max_size = 64M
max_execution_time = 300
max_input_time = 300
max_input_vars = 5000

; Error handling
display_errors = Off
log_errors = On
error_log = /var/log/php_errors.log

; Security enhancements
expose_php = Off
allow_url_fopen = Off
allow_url_include = Off

; Performance tuning
opcache.enable = 1
opcache.memory_consumption = 128
opcache.interned_strings_buffer = 8
opcache.max_accelerated_files = 4000
opcache.revalidate_freq = 60
opcache.fast_shutdown = 1
opcache.enable_cli = 1
PHP_OPTS
              
              # Create PHP error log
              sudo touch /var/log/php_errors.log
              sudo chown www-data:www-data /var/log/php_errors.log
              sudo chmod 644 /var/log/php_errors.log
              
              # Restart Apache to apply PHP changes
              sudo systemctl restart apache2
              
              echo "‚úÖ PHP configured and optimized"
            else
              echo "‚ùå PHP configuration file not found: $PHP_INI"
              return 1
            fi
          }
          
          # Execute service management
          echo "Starting service management process..."
          
          # MariaDB Configuration
          if configure_mariadb; then
            echo "‚úÖ MariaDB configured successfully"
          else
            echo "‚ö†Ô∏è MariaDB configuration had issues"
          fi
          
          # Apache Configuration
          if configure_apache; then
            echo "‚úÖ Apache configured successfully"
          else
            echo "‚ö†Ô∏è Apache configuration had issues"
          fi
          
          # PHP Configuration
          if configure_php; then
            echo "‚úÖ PHP configured successfully"
          else
            echo "‚ö†Ô∏è PHP configuration had issues"
          fi
          
          # Service status check
          echo "Checking service status..."
          SERVICES=("apache2" "mariadb" "ssh" "fail2ban" "ufw")
          for service in "${SERVICES[@]}"; do
            if systemctl is-active --quiet "$service"; then
              echo "‚úÖ $service is running"
            else
              echo "‚ùå $service is not running"
            fi
          done
          
          echo "‚úÖ Intelligent service management completed"

      - name: 'Setup Advanced Connection Methods'
        id: connection_setup
        run: |
          set -euo pipefail
          echo "üîó Setting up advanced connection methods..."
          
          # Function to setup Tailscale VPN
          setup_tailscale() {
            echo "Setting up Tailscale VPN..."
            
            # Check if Tailscale auth key is available
            if [[ -z "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
              echo "‚ö†Ô∏è TAILSCALE_AUTHKEY not found in secrets"
              echo "To use Tailscale, add your auth key to GitHub secrets:"
              echo "1. Go to https://login.tailscale.com/admin/settings/authkeys"
              echo "2. Generate a new auth key"
              echo "3. Add it as TAILSCALE_AUTHKEY secret"
              return 1
            fi
            
            # Install Tailscale
            echo "Installing Tailscale..."
            curl -fsSL https://tailscale.com/install.sh | sh
            
            # Connect to Tailscale network
            echo "Connecting to Tailscale network..."
            if sudo tailscale up --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" --ssh; then
              echo "‚úÖ Tailscale connected successfully"
              
              # Get Tailscale IP
              TAILSCALE_IP=$(tailscale ip -4 2>/dev/null || echo "unavailable")
              echo "Tailscale IP: $TAILSCALE_IP"
              echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
              
              return 0
            else
              echo "‚ùå Tailscale connection failed"
              return 1
            fi
          }
          
          # Function to setup tmate session
          setup_tmate() {
            echo "Setting up tmate session..."
            
            # Create tmate configuration
            cat << 'TMATE_CONFIG' > ~/.tmate.conf
set -g tmate-server-host "tmate.io"
set -g tmate-server-port 22
set -g tmate-server-rsa-fingerprint "SHA256:Hthk2T/M/Bqz/fsaONxJsH3Md0xHaJsaJ1h4Rfw2jXw"
set -g tmate-server-ed25519-fingerprint "SHA256:jfttvoypkHiQYUqUOJw0hPCGlqkJ9Wf19R9qf/hd3w8"
set -g tmate-identity ""
TMATE_CONFIG
            
            # Start tmate session in background
            echo "Starting tmate session..."
            nohup tmate -S /tmp/tmate.sock new-session -d > /dev/null 2>&1 &
            
            # Wait for tmate to initialize
            sleep 10
            
            # Get connection info
            if tmate -S /tmp/tmate.sock display -p > /tmp/tmate_info.txt 2>/dev/null; then
              TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo "unavailable")
              TMATE_WEB=$(tmate -S /tmp/tmate.sock display -p '#{tmate_web}' 2>/dev/null || echo "unavailable")
              
              echo "‚úÖ Tmate session started successfully"
              echo "SSH Command: $TMATE_SSH"
              echo "Web Terminal: $TMATE_WEB"
              echo "tmate_ssh=$TMATE_SSH" >> $GITHUB_OUTPUT
              echo "tmate_web=$TMATE_WEB" >> $GITHUB_OUTPUT
              
              return 0
            else
              echo "‚ùå Tmate session failed to start properly"
              return 1
            fi
          }
          
          # Setup connection methods
          TAILSCALE_STATUS="failed"
          TMATE_STATUS="failed"
          
          # Try Tailscale first
          if setup_tailscale; then
            TAILSCALE_STATUS="success"
          fi
          
          # Setup tmate as backup/alternative
          if setup_tmate; then
            TMATE_STATUS="success"
          fi
          
          # Output connection status
          echo "connection_tailscale=$TAILSCALE_STATUS" >> $GITHUB_OUTPUT
          echo "connection_tmate=$TMATE_STATUS" >> $GITHUB_OUTPUT
          
          # Ensure at least one connection method works
          if [[ "$TAILSCALE_STATUS" == "success" ]] || [[ "$TMATE_STATUS" == "success" ]]; then
            echo "‚úÖ At least one connection method is available"
          else
            echo "‚ö†Ô∏è No connection methods available - VPS will be accessible via local services only"
          fi
          
          echo "‚úÖ Advanced connection methods setup completed"

      - name: 'Create System Backup'
        id: backup_creation
        run: |
          set -euo pipefail
          echo "üíæ Creating comprehensive system backup..."
          
          # Function to create backup with metadata
          create_backup() {
            echo "Creating system backup..."
            
            BACKUP_DIR="/tmp/backup_$"
            mkdir -p "$BACKUP_DIR"
            chmod 700 "$BACKUP_DIR"
            
            # Create exclusion list
            cat << 'BACKUP_EXCLUDES' > "$BACKUP_DIR/excludes.txt"
/proc/*
/tmp/*
/sys/*
/dev/*
/run/*
/mnt/*
/media/*
/lost+found
/snap/*
/var/cache/*
/var/tmp/*
/var/log/*
/home/*/.cache/*
/root/.cache/*
*.log
*.tmp
*~
BACKUP_EXCLUDES
            
            # Calculate total size before backup
            echo "Calculating backup size..."
            TOTAL_SIZE=$(du -sb / --exclude-from="$BACKUP_DIR/excludes.txt" 2>/dev/null | awk '{print $1}' || echo "0")
            echo "Estimated backup size: $(echo $TOTAL_SIZE | numfmt --to=iec-i)B"
            
            # Create the backup archive
            BACKUP_FILE="$BACKUP_DIR/${{ env.BACKUP_NAME }}"
            echo "Creating backup archive..."
            
            if tar -czf "$BACKUP_FILE" \
                --exclude-from="$BACKUP_DIR/excludes.txt" \
                --absolute-names \
                --numeric-owner \
                --one-file-system / 2>/dev/null; then
              echo "‚úÖ Backup archive created successfully"
            else
              echo "‚ö†Ô∏è Backup archive created with warnings (normal for system files)"
            fi
            
            # Verify backup integrity
            echo "Verifying backup integrity..."
            if tar -tzf "$BACKUP_FILE" >/dev/null 2>&1; then
              echo "‚úÖ Backup integrity verified"
            else
              echo "‚ùå Backup integrity check failed"
              rm -rf "$BACKUP_DIR"
              return 1
            fi
            
            # Create backup metadata
            BACKUP_SIZE=$(stat -f%z "$BACKUP_FILE" 2>/dev/null || stat -c%s "$BACKUP_FILE" 2>/dev/null || echo "0")
            BACKUP_FILES=$(tar -tzf "$BACKUP_FILE" 2>/dev/null | wc -l)
            BACKUP_HASH=$(sha256sum "$BACKUP_FILE" | awk '{print $1}')
            
            cat > "$BACKUP_DIR/${{ env.BACKUP_METADATA }}" << EOF
{
  "version": "1.0",
  "created_at": "$(date -u -Iseconds)",
  "workflow_id": "${{ github.run_id }}",
  "workflow_number": "${{ github.run_number }}",
  "size_bytes": $BACKUP_SIZE,
  "size_human": "$(echo $BACKUP_SIZE | numfmt --to=iec-i)B",
  "file_count": $FILE_COUNT,
  "sha256": "$BACKUP_HASH",
  "hostname": "$(hostname)",
  "os_version": "$(lsb_release -d | cut -f2-)",
  "kernel_version": "$(uname -r)",
  "backup_method": "tar-gzip",
  "compression_ratio": $(echo "scale=2; $BACKUP_SIZE / $TOTAL_SIZE" | bc -l 2>/dev/null || echo "0.00")
}
EOF
            
            # Upload backup to cloud storage
            echo "Uploading backup to cloud storage..."
            
            # Upload with retry mechanism
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Upload attempt $attempt/$max_attempts..."
              
              if rclone copy "$BACKUP_FILE" "${{ env.MEGA_REMOTE }}/" \
                   --progress --retries 2 --stats 30s; then
                echo "‚úÖ Backup file uploaded successfully"
                
                # Upload metadata
                if rclone copy "$BACKUP_DIR/${{ env.BACKUP_METADATA }}" "${{ env.MEGA_REMOTE }}/" --retries 2; then
                  echo "‚úÖ Backup metadata uploaded successfully"
                  
                  # Cleanup local backup
                  rm -rf "$BACKUP_DIR"
                  return 0
                else
                  echo "‚ö†Ô∏è Metadata upload failed but backup succeeded"
                  rm -rf "$BACKUP_DIR"
                  return 0
                fi
              else
                echo "‚ùå Upload attempt $attempt failed"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Waiting 30 seconds before retry..."
                  sleep 30
                fi
              fi
              ((attempt++))
            done
            
            echo "‚ùå All upload attempts failed"
            rm -rf "$BACKUP_DIR"
            return 1
          }
          
          # Function to cleanup old backups
          cleanup_old_backups() {
            echo "Cleaning up old backups..."
            
            # List and remove old backups (keep only latest)
            if rclone ls "${{ env.MEGA_REMOTE }}" | grep -E "(vps-backup-.*\.tar\.gz|vps-backup-.*\.json)" | head -n -2 > /tmp/old_backups.txt; then
              while IFS= read -r line; do
                OLD_BACKUP=$(echo "$line" | awk '{print $2}')
                if [[ -n "$OLD_BACKUP" ]]; then
                  echo "Removing old backup: $OLD_BACKUP"
                  rclone delete "${{ env.MEGA_REMOTE }}/$OLD_BACKUP" || true
                fi
              done < /tmp/old_backups.txt
              rm -f /tmp/old_backups.txt
            fi
          }
          
          # Execute backup creation
          echo "Starting backup creation process..."
          
          # Create backup
          if create_backup; then
            echo "backup_created=true" >> $GITHUB_OUTPUT
            echo "‚úÖ System backup created and uploaded successfully"
            
            # Cleanup old backups
            cleanup_old_backups
          else
            echo "backup_created=false" >> $GITHUB_OUTPUT
            echo "‚ùå Backup creation failed"
          fi
          
          echo "‚úÖ Backup creation process completed"

      - name: 'Display System Status and Access Information'
        id: system_status
        run: |
          set -euo pipefail
          echo "üìä Displaying comprehensive system status..."
          
          # System Information
          echo "=================================="
          echo "üñ•Ô∏è  SYSTEM INFORMATION"
          echo "=================================="
          echo "Hostname: $(hostname)"
          echo "OS: $(lsb_release -d | cut -f2-)"
          echo "Kernel: $(uname -r)"
          echo "Architecture: $(uname -m)"
          echo "Uptime: $(uptime -p)"
          echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
          echo "CPU Cores: $(nproc)"
          echo "Memory: $(free -h | awk 'NR==2{printf "%.1fGB / %.1fGB (%.1f%%)", $3/1024/1024, $2/1024/1024, $3*100/$2}')"
          echo "Disk Usage: $(df -h / | awk 'NR==2{printf "%s / %s (%s)", $3, $2, $5}')"
          echo ""
          
          # Network Information
          echo "=================================="
          echo "üåê NETWORK INFORMATION"
          echo "=================================="
          echo "Public IP: $(curl -s https://ipinfo.io/ip || echo 'Unable to detect')"
          echo "Local IP: $(hostname -I | awk '{print $1}')"
          if [[ -n "${{ steps.connection_setup.outputs.tailscale_ip || '' }}" && "${{ steps.connection_setup.outputs.tailscale_ip }}" != "unavailable" ]]; then
            echo "Tailscale IP: ${{ steps.connection_setup.outputs.tailscale_ip }}"
          fi
          echo ""
          
          # Service Status
          echo "=================================="
          echo "‚öôÔ∏è  SERVICE STATUS"
          echo "=================================="
          SERVICES=("apache2" "mariadb" "ssh" "fail2ban" "ufw" "system-monitor")
          for service in "${SERVICES[@]}"; do
            if systemctl is-active --quiet "$service"; then
              echo "‚úÖ $service: Running"
            else
              echo "‚ùå $service: Stopped"
            fi
          done
          echo ""
          
          # Access Information
          echo "=================================="
          echo "üîë ACCESS INFORMATION"
          echo "=================================="
          echo "SSH User: ${{ env.VPS_USER }}"
          echo "SSH Password: ${{ env.VPS_PASSWORD }}"
          echo ""
          
          # Connection Methods
          echo "üîó Connection Methods:"
          if [[ "${{ steps.connection_setup.outputs.connection_tailscale }}" == "success" ]]; then
            echo "‚úÖ Tailscale VPN: Connected"
            echo "   SSH via Tailscale: ssh ${{ env.VPS_USER }}@${{ steps.connection_setup.outputs.tailscale_ip }}"
          fi
          
          if [[ "${{ steps.connection_setup.outputs.connection_tmate }}" == "success" ]]; then
            echo "‚úÖ Tmate Terminal Sharing: Available"
            if [[ -n "${{ steps.connection_setup.outputs.tmate_ssh || '' }}" ]]; then
              echo "   SSH Command: ${{ steps.connection_setup.outputs.tmate_ssh }}"
            fi
            if [[ -n "${{ steps.connection_setup.outputs.tmate_web || '' }}" ]]; then
              echo "   Web Terminal: ${{ steps.connection_setup.outputs.tmate_web }}"
            fi
          fi
          echo ""
          
          # Web Services
          echo "üåê Web Services:"
          echo "‚úÖ Apache Web Server: http://localhost/"
          echo "‚úÖ PHP Info Page: http://localhost/phpinfo.php?allow=1"
          if [[ "${{ steps.aapanel_recovery.outputs.aapanel_status || steps.fresh_install.outputs.aapanel_installed }}" == "success" || "${{ steps.fresh_install.outputs.aapanel_installed }}" == "true" ]]; then
            echo "‚úÖ Aapanel Control Panel: http://localhost:7800/"
            echo "   Username: ${{ env.AAPANEL_USER }}"
            echo "   Password: ${{ env.AAPANEL_PASSWORD }}"
          fi
          echo ""
          
          # Database Information
          echo "üíæ Database Access:"
          echo "‚úÖ MariaDB/MySQL Server: localhost:3306"
          echo "   Root Password: root"
          echo "   App User: vps_user"
          echo "   App Password: vps_password"
          echo ""
          
          # Security Information
          echo "=================================="
          echo "üõ°Ô∏è  SECURITY STATUS"
          echo "=================================="
          echo "Firewall (UFW): $(sudo ufw status | head -1)"
          echo "Fail2Ban: $(systemctl is-active fail2ban || echo 'inactive')"
          echo "SSH Key Auth: $([ -f /home/${{ env.VPS_USER }}/.ssh/id_rsa.pub ] && echo 'Configured' || echo 'Not configured')"
          echo ""
          
          # Backup Status
          echo "=================================="
          echo "üíæ BACKUP STATUS"
          echo "=================================="
          if [[ "${{ steps.backup_creation.outputs.backup_created }}" == "true" ]]; then
            echo "‚úÖ System backup created and uploaded"
          else
            echo "‚ùå Backup creation failed"
          fi
          echo "Backup Location: ${{ env.MEGA_REMOTE }}"
          echo "Restoration: $(if [[ "${{ env.SKIP_RESTORE }}" == "true" ]]; then echo 'Skipped'; else echo '${{ steps.restore.outputs.restore_status }}'; fi)"
          echo ""
          
          # Session Information
          echo "=================================="
          echo "‚è∞ SESSION INFORMATION"
          echo "=================================="
          echo "Session Duration: ${{ env.SESSION_TIMEOUT }} minutes"
          echo "Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Estimated End: $(date -u -d '+${{ env.SESSION_TIMEOUT }} minutes' '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Workflow ID: ${{ github.run_id }}"
          echo "Run Number: ${{ github.run_number }}"
          echo ""
          
          # Warning and Tips
          echo "=================================="
          echo "‚ö†Ô∏è  IMPORTANT NOTES"
          echo "=================================="
          echo "‚Ä¢ This is a temporary VPS that will terminate after ${{ env.SESSION_TIMEOUT }} minutes"
          echo "‚Ä¢ Change default passwords before exposing services publicly"
          echo "‚Ä¢ Use the backup system to preserve your work"
          echo "‚Ä¢ Monitor resource usage to avoid hitting limits"
          echo "‚Ä¢ Check service logs if you encounter issues"
          echo ""
          
          echo "status=online" >> $GITHUB_OUTPUT
          echo "‚úÖ System status display completed"

      - name: 'Maintain Session'
        id: maintain_session
        run: |
          set -euo pipefail
          echo "üïê Maintaining session for ${{ env.SESSION_TIMEOUT }} minutes..."
          
          # Calculate end time
          END_TIME=$(($(date +%s) + ${{ env.SESSION_TIMEOUT }} * 60))
          
          # Session maintenance loop
          while [ $(date +%s) -lt $END_TIME ]; do
            REMAINING=$((($END_TIME - $(date +%s)) / 60))
            
            echo "‚è∞ Session remaining: $REMAINING minutes"
            
            # Health checks every 5 minutes
            if [ $(($(date +%s) % 300)) -eq 0 ]; then
              echo "üîç Performing health check..."
              
              # Check critical services
              CRITICAL_SERVICES=("apache2" "mariadb" "ssh")
              for service in "${CRITICAL_SERVICES[@]}"; do
                if ! systemctl is-active --quiet "$service"; then
                  echo "‚ö†Ô∏è Service $service is down, attempting restart..."
                  sudo systemctl restart "$service" || echo "‚ùå Failed to restart $service"
                fi
              done
              
              # Check disk space
              DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
              if [ "$DISK_USAGE" -gt 90 ]; then
                echo "‚ö†Ô∏è Disk usage critical: ${DISK_USAGE}%"
                echo "Cleaning temporary files..."
                sudo find /tmp -type f -atime +1 -delete 2>/dev/null || true
                sudo apt-get autoremove -y 2>/dev/null || true
                sudo apt-get autoclean 2>/dev/null || true
              fi
              
              # Check memory usage
              MEM_USAGE=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100}')
              if [ "$MEM_USAGE" -gt 85 ]; then
                echo "‚ö†Ô∏è Memory usage high: ${MEM_USAGE}%"
                echo "Clearing caches..."
                sudo sync && echo 1 | sudo tee /proc/sys/vm/drop_caches >/dev/null
              fi
            fi
            
            # Display status every 10 minutes
            if [ $(($(date +%s) % 600)) -eq 0 ]; then
              echo "üìä Current system status:"
              echo "  Load: $(uptime | awk -F'load average:' '{print $2}')"
              echo "  Memory: $(free -h | awk 'NR==2{printf "%.1fGB used of %.1fGB", $3/1024/1024, $2/1024/1024}')"
              echo "  Disk: $(df -h / | awk 'NR==2{printf "%s used of %s", $3, $2}')"
              echo "  Connections: $(ss -tuln | wc -l) listening sockets"
            fi
            
            # Keep the runner alive
            echo "üíì Heartbeat - Session active"
            sleep 60
          done
          
          echo "‚è∞ Session timeout reached"
          echo "session_ended=true" >> $GITHUB_OUTPUTname: Enhanced Persistent VPS

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:      # Manual trigger
    inputs:
      session_duration:
        description: 'Session duration in minutes (max 350)'
        required: false
        default: '330'
        type: string
      skip_backup_restore:
        description: 'Skip backup restoration (fresh install)'
        required: false
        default: false
        type: boolean
      enable_debug_mode:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean

env:
  BACKUP_STORE: /var/backups/vps
  BACKUP_NAME: vps-backup-latest.tar.gz
  BACKUP_METADATA: vps-backup-metadata.json
  MEGA_REMOTE: mega:vps-backup
  VPS_USER: jacky
  VPS_PASSWORD: root
  AAPANEL_USER: jacky
  AAPANEL_PASSWORD: spidey123
  SESSION_TIMEOUT: ${{ github.event.inputs.session_duration || '330' }}
  DEBUG_MODE: ${{ github.event.inputs.enable_debug_mode || 'false' }}
  SKIP_RESTORE: ${{ github.event.inputs.skip_backup_restore || 'false' }}
  MAX_RETRY_ATTEMPTS: 5
  HEALTH_CHECK_INTERVAL: 30
  BACKUP_RETENTION_DAYS: 7

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 360  # 6 hours maximum
    
    outputs:
      session_status: ${{ steps.session_status.outputs.status }}
      tailscale_ip: ${{ steps.connection_info.outputs.tailscale_ip }}
      backup_created: ${{ steps.backup_status.outputs.created }}
    
    steps:
      - name: 'Initialize Workflow'
        id: init
        run: |
          echo "üöÄ Starting Enhanced Persistent VPS Workflow"
          echo "Workflow initiated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Session duration: ${{ env.SESSION_TIMEOUT }} minutes"
          echo "Debug mode: ${{ env.DEBUG_MODE }}"
          echo "Skip restore: ${{ env.SKIP_RESTORE }}"
          
          # Set debug mode
          if [[ "${{ env.DEBUG_MODE }}" == "true" ]]; then
            set -x
            echo "DEBUG_ENABLED=true" >> $GITHUB_ENV
          fi
          
          # Validate inputs
          if [[ "${{ env.SESSION_TIMEOUT }}" -gt 350 ]]; then
            echo "‚ö†Ô∏è Session timeout exceeds maximum, setting to 350 minutes"
            echo "SESSION_TIMEOUT=350" >> $GITHUB_ENV
          fi
          
          # Create workflow metadata
          cat > /tmp/workflow_metadata.json << EOF
          {
            "workflow_id": "${{ github.run_id }}",
            "workflow_number": "${{ github.run_number }}",
            "started_at": "$(date -u -Iseconds)",
            "session_duration": "${{ env.SESSION_TIMEOUT }}",
            "debug_mode": "${{ env.DEBUG_MODE }}",
            "skip_restore": "${{ env.SKIP_RESTORE }}",
            "runner_os": "$(lsb_release -d | cut -f2)"
          }
          EOF
          
          echo "‚úÖ Workflow initialization complete"

      - name: 'Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 'Advanced System Health Check'
        id: health_check
        run: |
          set -euo pipefail
          echo "üîç Performing comprehensive system health check..."
          
          # Initialize health check results
          HEALTH_STATUS="healthy"
          WARNINGS=()
          ERRORS=()
          
          # Check disk space with multiple thresholds
          ROOT_USAGE=$(df / --output=pcent | tail -1 | tr -d '% ')
          if [ "$ROOT_USAGE" -gt 95 ]; then
            ERRORS+=("Critical: Root filesystem $ROOT_USAGE% full")
            HEALTH_STATUS="critical"
          elif [ "$ROOT_USAGE" -gt 85 ]; then
            WARNINGS+=("Warning: Root filesystem $ROOT_USAGE% full")
          fi
          
          # Check available memory
          TOTAL_MEM=$(grep MemTotal /proc/meminfo | awk '{print $2}')
          AVAIL_MEM=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
          MEM_USAGE=$((100 - (AVAIL_MEM * 100 / TOTAL_MEM)))
          
          if [ "$MEM_USAGE" -gt 90 ]; then
            ERRORS+=("Critical: Memory usage at $MEM_USAGE%")
            HEALTH_STATUS="critical"
          elif [ "$MEM_USAGE" -gt 80 ]; then
            WARNINGS+=("Warning: Memory usage at $MEM_USAGE%")
          fi
          
          # Check CPU load
          LOAD_AVG=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
          CPU_CORES=$(nproc)
          if (( $(echo "$LOAD_AVG > $CPU_CORES * 2" | bc -l) )); then
            WARNINGS+=("Warning: High CPU load: $LOAD_AVG")
          fi
          
          # Check for required commands
          REQUIRED_COMMANDS=("curl" "wget" "tar" "systemctl")
          for cmd in "${REQUIRED_COMMANDS[@]}"; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              ERRORS+=("Critical: Required command '$cmd' not found")
              HEALTH_STATUS="critical"
            fi
          done
          
          # Report health status
          echo "System Health Status: $HEALTH_STATUS"
          echo "Disk Usage: $ROOT_USAGE%"
          echo "Memory Usage: $MEM_USAGE%"
          echo "CPU Load: $LOAD_AVG (cores: $CPU_CORES)"
          echo "Available Space: $(df -h / | tail -1 | awk '{print $4}')"
          
          # Output warnings
          if [ ${#WARNINGS[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è Warnings:"
            printf '%s\n' "${WARNINGS[@]}"
          fi
          
          # Output errors and exit if critical
          if [ ${#ERRORS[@]} -gt 0 ]; then
            echo "‚ùå Errors:"
            printf '%s\n' "${ERRORS[@]}"
            if [ "$HEALTH_STATUS" = "critical" ]; then
              echo "System health check failed - aborting"
              exit 1
            fi
          fi
          
          echo "health_status=$HEALTH_STATUS" >> $GITHUB_OUTPUT
          echo "‚úÖ System health check completed"

      - name: 'Install Enhanced System Tools'
        id: install_tools
        run: |
          set -euo pipefail
          echo "üì¶ Installing enhanced system tools and dependencies..."
          
          # Function for retrying package installation
          retry_install() {
            local max_attempts=3
            local attempt=1
            local packages="$*"
            
            while [ $attempt -le $max_attempts ]; do
              echo "Installation attempt $attempt/$max_attempts for: $packages"
              if sudo DEBIAN_FRONTEND=noninteractive apt-get install -y $packages; then
                echo "‚úÖ Successfully installed: $packages"
                return 0
              else
                echo "‚ùå Installation attempt $attempt failed"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Waiting 10 seconds before retry..."
                  sleep 10
                  sudo apt-get update -qq
                fi
                ((attempt++))
              fi
            done
            
            echo "‚ùå Failed to install after $max_attempts attempts: $packages"
            return 1
          }
          
          # Update package lists with retry
          echo "Updating package lists..."
          for i in {1..3}; do
            if sudo apt-get update -qq; then
              break
            elif [ $i -eq 3 ]; then
              echo "Failed to update package lists after 3 attempts"
              exit 1
            fi
            sleep 5
          done
          
          # Install core system packages
          echo "Installing core system packages..."
          retry_install \
            psmisc screen openssh-server curl wget unzip tar gzip \
            htop nano vim git net-tools expect ufw fail2ban \
            bc jq tree rsync lsof tcpdump iotop dstat \
            software-properties-common apt-transport-https ca-certificates \
            gnupg lsb-release
          
          # Install web server stack
          echo "Installing web server stack..."
          retry_install \
            apache2 mariadb-server \
            php php-mysql php-cli php-curl php-zip php-gd php-mbstring \
            php-xml php-json php-intl php-opcache php-readline
          
          # Install additional monitoring tools
          echo "Installing monitoring and security tools..."
          retry_install \
            iftop nethogs vnstat logwatch \
            rkhunter chkrootkit clamav clamav-daemon \
            aide tripwire
          
          # Install tmate with fallback
          echo "Installing tmate..."
          if ! retry_install tmate; then
            echo "Falling back to manual tmate installation..."
            TMATE_VERSION="2.4.0"
            TMATE_ARCH="amd64"
            TMATE_URL="https://github.com/tmate-io/tmate/releases/download/${TMATE_VERSION}/tmate-${TMATE_VERSION}-static-linux-${TMATE_ARCH}.tar.xz"
            
            wget -q -O /tmp/tmate.tar.xz "$TMATE_URL"
            tar -xf /tmp/tmate.tar.xz -C /tmp/
            sudo cp "/tmp/tmate-${TMATE_VERSION}-static-linux-${TMATE_ARCH}/tmate" /usr/local/bin/
            sudo chmod +x /usr/local/bin/tmate
            rm -rf /tmp/tmate*
          fi
          
          # Install rclone with verification
          echo "Installing rclone..."
          if ! curl -fsSL https://rclone.org/install.sh | sudo bash; then
            echo "Rclone installation failed"
            exit 1
          fi
          
          # Verify critical installations
          echo "Verifying installations..."
          REQUIRED_TOOLS=("rclone" "tmate" "php" "apache2" "mysql")
          for tool in "${REQUIRED_TOOLS[@]}"; do
            if command -v "$tool" >/dev/null 2>&1; then
              version=$("$tool" --version 2>/dev/null | head -1 || echo "Version unavailable")
              echo "‚úÖ $tool: $version"
            else
              echo "‚ùå $tool: Not found or not working"
              exit 1
            fi
          done
          
          # Create installation manifest
          cat > /tmp/installation_manifest.txt << EOF
          Installation completed: $(date -u -Iseconds)
          Packages installed: $(dpkg --get-selections | wc -l)
          Disk usage after install: $(df -h / | tail -1 | awk '{print $3"/"$2" ("$5")"}')
          EOF
          
          echo "‚úÖ Enhanced system tools installation completed"

      - name: 'Configure Advanced Rclone Setup'
        id: rclone_setup
        run: |
          set -euo pipefail
          echo "‚öôÔ∏è Configuring advanced rclone setup..."
          
          # Validate rclone config secret
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            cat << 'EOF'
          ‚ùå RCLONE_CONFIG secret is missing!
          
          Please add your rclone configuration to GitHub secrets:
          1. Run 'rclone config' locally to set up MEGA
          2. Copy the contents of ~/.config/rclone/rclone.conf
          3. Add it as a secret named RCLONE_CONFIG in your repository
          
          To configure MEGA:
          - Choose 'n' for new remote
          - Name: mega
          - Storage: mega
          - Enter your MEGA credentials
          EOF
            exit 1
          fi
          
          # Create rclone directories with proper permissions
          mkdir -p ~/.config/rclone ~/.cache/rclone
          chmod 700 ~/.config/rclone ~/.cache/rclone
          
          # Write rclone configuration
          cat > ~/.config/rclone/rclone.conf << 'EOF'
          ${{ secrets.RCLONE_CONFIG }}
          EOF
          
          chmod 600 ~/.config/rclone/rclone.conf
          
          # Validate configuration format
          echo "Validating rclone configuration..."
          if ! rclone config show >/dev/null 2>&1; then
            echo "‚ùå Invalid rclone configuration format"
            echo "Available remotes:"
            rclone listremotes 2>&1 || echo "No remotes found"
            exit 1
          fi
          
          # Check for MEGA remote specifically
          if ! rclone listremotes | grep -q "mega:"; then
            echo "‚ùå MEGA remote not found in configuration"
            echo "Available remotes:"
            rclone listremotes
            exit 1
          fi
          
          echo "‚úÖ Rclone configuration validated successfully"

      - name: 'Test Cloud Storage Connectivity'
        id: cloud_test
        run: |
          set -euo pipefail
          echo "üîó Testing cloud storage connectivity..."
          
          # Test with exponential backoff
          test_connection() {
            local max_attempts=${{ env.MAX_RETRY_ATTEMPTS }}
            local attempt=1
            local delay=5
            
            while [ $attempt -le $max_attempts ]; do
              echo "Connection test attempt $attempt/$max_attempts..."
              
              if timeout 90 rclone about "${{ env.MEGA_REMOTE }}" 2>/dev/null; then
                echo "‚úÖ MEGA connection successful on attempt $attempt"
                
                # Get storage info
                STORAGE_INFO=$(rclone about "${{ env.MEGA_REMOTE }}" 2>/dev/null || echo "Storage info unavailable")
                echo "Storage Information:"
                echo "$STORAGE_INFO"
                
                return 0
              else
                echo "‚ùå Connection attempt $attempt failed"
                if [ $attempt -lt $max_attempts ]; then
                  echo "Waiting $delay seconds before retry..."
                  sleep $delay
                  delay=$((delay * 2))  # Exponential backoff
                fi
              fi
              ((attempt++))
            done
            
            echo "‚ùå MEGA connection failed after $max_attempts attempts"
            echo "Debugging information:"
            rclone about "${{ env.MEGA_REMOTE }}" || true
            return 1
          }
          
          if ! test_connection; then
            exit 1
          fi
          
          # Test file operations
          echo "Testing file operations..."
          TEST_FILE="/tmp/connectivity_test.txt"
          echo "Connectivity test $(date -u -Iseconds)" > "$TEST_FILE"
          
          if rclone copy "$TEST_FILE" "${{ env.MEGA_REMOTE }}/tests/" --retries 2; then
            echo "‚úÖ File upload test successful"
            rclone delete "${{ env.MEGA_REMOTE }}/tests/connectivity_test.txt" || true
          else
            echo "‚ö†Ô∏è File upload test failed (continuing anyway)"
          fi
          
          rm -f "$TEST_FILE"
          echo "‚úÖ Cloud storage connectivity test completed"

      - name: 'Intelligent Backup Restoration'
        id: restore
        run: |
          set -euo pipefail
          echo "üíæ Starting intelligent backup restoration process..."
          
          # Skip restoration if requested
          if [[ "${{ env.SKIP_RESTORE }}" == "true" ]]; then
            echo "‚è≠Ô∏è Backup restoration skipped by user request"
            echo "is_new_install=true" >> $GITHUB_OUTPUT
            echo "restore_status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Function to check backup existence and metadata
          check_backup() {
            echo "Checking for existing backup..."
            
            # Check if backup file exists
            if ! timeout 120 rclone ls "${{ env.MEGA_REMOTE }}/${{ env.BACKUP_NAME }}" >/dev/null 2>&1; then
              echo "No backup file found"
              return 1
            fi
            
            # Check backup age and metadata
            if rclone ls "${{ env.MEGA_REMOTE }}/${{ env.BACKUP_METADATA }}" >/dev/null 2>&1; then
              echo "Downloading backup metadata..."
              rclone copy "${{ env.MEGA_REMOTE }}/${{ env.BACKUP_METADATA }}" /tmp/ --retries 2
              
              if [[ -f "/tmp/${{ env.BACKUP_METADATA }}" ]]; then
                BACKUP_DATE=$(jq -r '.created_at // empty' "/tmp/${{ env.BACKUP_METADATA }}" 2>/dev/null || echo "")
                BACKUP_SIZE=$(jq -r '.size_bytes // empty' "/tmp/${{ env.BACKUP_METADATA }}" 2>/dev/null || echo "")
                BACKUP_VERSION=$(jq -r '.version // empty' "/tmp/${{ env.BACKUP_METADATA }}" 2>/dev/null || echo "")
                
                echo "Backup metadata:"
                echo "  Date: $BACKUP_DATE"
                echo "  Size: $BACKUP_SIZE bytes"
                echo "  Version: $BACKUP_VERSION"
                
                # Check if backup is too old (more than 7 days)
                if [[ -n "$BACKUP_DATE" ]]; then
                  BACKUP_TIMESTAMP=$(date -d "$BACKUP_DATE" +%s 2>/dev/null || echo "0")
                  CURRENT_TIMESTAMP=$(date +%s)
                  AGE_DAYS=$(( (CURRENT_TIMESTAMP - BACKUP_TIMESTAMP) / 86400 ))
                  
                  if [[ $AGE_DAYS -gt ${{ env.BACKUP_RETENTION_DAYS }} ]]; then
                    echo "‚ö†Ô∏è Backup is $AGE_DAYS days old (threshold: ${{ env.BACKUP_RETENTION_DAYS }} days)"
                    echo "Skipping old backup restoration"
                    return 1
                  fi
                fi
              fi
            fi
            
            return 0
          }
          
          # Restore function with integrity checks
          restore_backup() {
            echo "Starting backup restoration..."
            
            # Create secure restore directory
            RESTORE_DIR="/tmp/restore_$$"
            mkdir -p "$RESTORE_DIR"
            chmod 700 "$RESTORE_DIR"
            
            # Download backup with progress and verification
            echo "Downloading backup (this may take a while)..."
            if ! rclone copy "${{ env.MEGA_REMOTE }}/${{ env.BACKUP_NAME }}" "$RESTORE_DIR/" \
                 --progress --retries 3 --low-level-retries 3 --stats 30s; then
              echo "‚ùå Backup download failed"
              rm -rf "$RESTORE_DIR"
              return 1
            fi
            
            BACKUP_FILE="$RESTORE_DIR/${{ env.BACKUP_NAME }}"
            
            # Verify backup integrity with multiple checks
            echo "Verifying backup integrity..."
            
            # Check file exists and is not empty
            if [[ ! -s "$BACKUP_FILE" ]]; then
              echo "‚ùå Backup file is empty or missing"
              rm -rf "$RESTORE_DIR"
              return 1
            fi
            
            # Test archive integrity
            if ! tar -tzf "$BACKUP_FILE" >/dev/null 2>&1; then
              echo "‚ùå Backup archive is corrupted"
              rm -rf "$RESTORE_DIR"
              return 1
            fi
            
            # Get file count for progress estimation
            FILE_COUNT=$(tar -tzf "$BACKUP_FILE" 2>/dev/null | wc -l)
            echo "Backup contains $FILE_COUNT files/directories"
            
            # Extract with progress indication
            echo "Extracting backup to system..."
            (
              tar -xzf "$BACKUP_FILE" --absolute-names -C / \
                  --exclude='proc/*' --exclude='tmp/*' --exclude='sys/*' \
                  --exclude='dev/*' --exclude='run/*' 2>/dev/null || {
                echo "‚ö†Ô∏è Some files failed to restore (normal for system files)"
              }
            ) &
            
            # Show progress while extraction happens
            TAR_PID=$!
            while kill -0 $TAR_PID 2>/dev/null; do
              echo -n "."
              sleep 2
            done
            echo " Done!"
            
            wait $TAR_PID
            EXTRACT_STATUS=$?
            
            # Cleanup
            rm -rf "$RESTORE_DIR"
            
            if [[ $EXTRACT_STATUS -eq 0 ]]; then
              echo "‚úÖ Backup restoration completed successfully"
              return 0
            else
              echo "‚ö†Ô∏è Backup restoration completed with warnings"
              return 0  # Continue anyway, warnings are expected
            fi
          }
          
          # Main restoration logic
          if check_backup; then
            if restore_backup; then
              echo "is_new_install=false" >> $GITHUB_OUTPUT
              echo "restore_status=success" >> $GITHUB_OUTPUT
              
              # Post-restoration system repairs
              echo "Performing post-restoration system repairs..."
              
              # Fix common permission issues
              sudo chown -R www-data:www-data /var/www/ 2>/dev/null || true
              sudo chmod -R 755 /var/www/html/ 2>/dev/null || true
              
              # Fix SSH permissions
              sudo chmod 700 /home/*/.ssh 2>/dev/null || true
              sudo chmod 600 /home/*/.ssh/* 2>/dev/null || true
              
              echo "‚úÖ Post-restoration repairs completed"
            else
              echo "‚ùå Backup restoration failed"
              echo "is_new_install=true" >> $GITHUB_OUTPUT
              echo "restore_status=failed" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è No valid backup found or backup check failed"
            echo "Proceeding with fresh installation..."
            echo "is_new_install=true" >> $GITHUB_OUTPUT
            echo "restore_status=no_backup" >> $GITHUB_OUTPUT
          fi

      - name: 'Advanced Aapanel Recovery'
        if: steps.restore.outputs.is_new_install == 'false'
        id: aapanel_recovery
        run: |
          set -euo pipefail
          echo "üîß Performing advanced Aapanel recovery..."
          
          # Function to check Aapanel installation
          check_aapanel() {
            echo "Checking Aapanel installation status..."
            
            # Check for Aapanel directories
            if [[ -d "/www" ]]; then
              echo "‚úÖ Aapanel directory structure found"
              AAPANEL_DETECTED=true
            else
              echo "‚ÑπÔ∏è No Aapanel directory structure found"
              AAPANEL_DETECTED=false
              return 1
            fi
            
            # Check for bt command
            if command -v bt >/dev/null 2>&1; then
              echo "‚úÖ bt command is available"
              BT_AVAILABLE=true
            else
              echo "‚ö†Ô∏è bt command not found"
              BT_AVAILABLE=false
            fi
            
            # Check panel service
            if systemctl list-unit-files | grep -q "panel.service"; then
              echo "‚úÖ Panel service found"
              SERVICE_AVAILABLE=true
            else
              echo "‚ö†Ô∏è Panel service not found"
              SERVICE_AVAILABLE=false
            fi
            
            return 0
          }
          
          # Function to repair bt command
          repair_bt_command() {
            echo "Repairing bt command..."
            
            # Look for bt in common locations
            BT_LOCATIONS=(
              "/www/server/panel/bt"
              "/www/server/panel/bt.py"
              "/usr/bin/bt"
              "/usr/local/bin/bt"
            )
            
            for location in "${BT_LOCATIONS[@]}"; do
              if [[ -f "$location" ]]; then
                echo "Found bt at: $location"
                sudo ln -sf "$location" /usr/bin/bt 2>/dev/null || true
                sudo chmod +x /usr/bin/bt 2>/dev/null || true
                
                # Test the command
                if command -v bt >/dev/null 2>&1; then
                  echo "‚úÖ bt command restored successfully"
                  return 0
                fi
              fi
            done
            
            echo "‚ö†Ô∏è Could not restore bt command from existing files"
            return 1
          }
          
          # Function to reinstall Aapanel
          reinstall_aapanel() {
            echo "Reinstalling Aapanel..."
            
            # Backup existing configuration
            if [[ -d "/www/server/panel/data" ]]; then
              echo "Backing up existing panel configuration..."
              sudo cp -r /www/server/panel/data /tmp/panel_data_backup 2>/dev/null || true
            fi
            
            # Download and install Aapanel
            INSTALL_URLS=(
              "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"
              "https://raw.githubusercontent.com/aaPanel/aaPanel/master/script/install_6.0_en.sh"
              "https://download.aapanel.com/install/install-ubuntu_6.0_en.sh"
            )
            
            for url in "${INSTALL_URLS[@]}"; do
              echo "Trying installation from: $url"
              if curl -fsSL -o /tmp/install_aapanel.sh "$url" --connect-timeout 30; then
                chmod +x /tmp/install_aapanel.sh
                
                # Install with timeout and expect
                if timeout 600 bash -c '
                  sudo expect -c "
                    set timeout 600
                    spawn bash /tmp/install_aapanel.sh
                    expect {
                      \"Do you want to install aaPanel to the /www directory now?*\" {
                        send \"y\\r\"
                        expect eof
                      }
                      timeout {
                        puts \"Installation timed out\"
                        exit 1
                      }
                    }
                  "
                '; then
                  echo "‚úÖ Aapanel installation completed"
                  
                  # Restore configuration if backup exists
                  if [[ -d "/tmp/panel_data_backup" ]]; then
                    echo "Restoring panel configuration..."
                    sudo cp -r /tmp/panel_data_backup/* /www/server/panel/data/ 2>/dev/null || true
                    sudo rm -rf /tmp/panel_data_backup
                  fi
                  
                  return 0
                else
                  echo "‚ö†Ô∏è Installation from $url failed"
                fi
                
                rm -f /tmp/install_aapanel.sh
              else
                echo "‚ö†Ô∏è Could not download from $url"
              fi
            done
            
            echo "‚ùå All Aapanel installation attempts failed"
            return 1
          }
          
          # Function to configure Aapanel
          configure_aapanel() {
            echo "Configuring Aapanel..."
            
            # Wait for services to be ready
            sleep 10
            
            # Set credentials
            if command -v bt >/dev/null 2>&1; then
              echo "Setting Aapanel credentials..."
              
              # Set username
              echo "${{ env.AAPANEL_USER }}" | sudo bt 6 2>/dev/null || \
                echo "‚ö†Ô∏è Could not set Aapanel username"
              
              # Set password
              echo "${{ env.AAPANEL_PASSWORD }}" | sudo bt 5 2>/dev/null || \
                echo "‚ö†Ô∏è Could not set Aapanel password"
              
              # Get panel info
              echo "Aapanel access information:"
              sudo bt default 2>/dev/null || echo "Could not retrieve panel info"
              
              return 0
            else
              echo "‚ùå bt command still not available after configuration"
              return 1
            fi
          }
          
          # Main recovery process
          RECOVERY_STATUS="unknown"
          
          if check_aapanel; then
            echo "Aapanel installation detected, performing recovery..."
            
            # Try to repair bt command first
            if [[ "$BT_AVAILABLE" == "false" ]]; then
              if repair_bt_command; then
                RECOVERY_STATUS="bt_repaired"
              else
                echo "bt command repair failed, attempting reinstallation..."
                if reinstall_aapanel; then
                  RECOVERY_STATUS="reinstalled"
                else
                  RECOVERY_STATUS="failed"
                fi
              fi
            else
              echo "bt command already available"
              RECOVERY_STATUS="already_working"
            fi
            
            # Configure Aapanel if recovery was successful
            if [[ "$RECOVERY_STATUS" != "failed" ]]; then
              if configure_aapanel; then
                echo "‚úÖ Aapanel recovery completed successfully"
              else
                echo "‚ö†Ô∏è Aapanel recovery completed but configuration failed"
                RECOVERY_STATUS="config_failed"
              fi
            fi
          else
            echo "‚ÑπÔ∏è No Aapanel installation detected, skipping recovery"
            RECOVERY_STATUS="not_installed"
          fi
          
          echo "aapanel_status=$RECOVERY_STATUS" >> $GITHUB_OUTPUT
          echo "‚úÖ Aapanel recovery process completed"

      - name: 'Comprehensive Fresh Installation'
        if: steps.restore.outputs.is_new_install == 'true'
        id: fresh_install
        run: |
          set -euo pipefail
          echo "üÜï Performing comprehensive fresh installation..."
          
          # Function to create user accounts
          setup_users() {
            echo "Setting up user accounts..."
            
            # Create main user
            if ! id "${{ env.VPS_USER }}" &>/dev/null; then
              sudo useradd -m -s /bin/bash -G sudo "${{ env.VPS_USER }}"
              echo "‚úÖ User '${{ env.VPS_USER }}' created"
            else
              echo "‚ÑπÔ∏è User '${{ env.VPS_USER }}' already exists"
            fi
            
            # Set password and configure sudo
            echo "${{ env.VPS_USER }}:${{ env.VPS_PASSWORD }}" | sudo chpasswd
            sudo usermod -aG sudo "${{ env.VPS_USER }}"
            sudo usermod -aG www-data "${{ env.VPS_USER }}"
            
            # Configure
