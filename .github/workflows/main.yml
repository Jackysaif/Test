name: Spidey Persistent VPS Orchestrator
description: |
  This workflow automates the creation of a persistent VPS environment named 'Spidey'.
  It handles user setup, software installation, state persistence via GitHub/Mega backups,
  and operates on a 6-hour lifecycle with graceful shutdown and restore capabilities.

# --- SCHEDULE & SESSION CONTROL ---
# Runs every 6 hours, allowing 30 mins for backup. Session live for ~5h 30m.
on:
  schedule:
    - cron: '0 */6 * * *' # At minute 0 of every 6th hour
  workflow_dispatch: # Allows manual triggering

# --- ENVIRONMENT VARIABLES ---
env:
  VPS_HOSTNAME: Spidey
  SUDO_USER: Jacky
  USER_PASSWORD: spidey
  BT_USERNAME: Jacky
  BT_PASSWORD: spidey
  BACKUP_ARTIFACT_NAME: spidey-persistent-state
  MEGA_CREDENTIALS: ${{ secrets.MEGA_CREDENTIALS }} # Format: email:password
  META_FILE_URL: https://raw.githubusercontent.com/YourGitHubUser/YourRepo/main/mega_backup_url.txt

# --- THE MAIN WORKFLOW ---
jobs:
  orchestrate-session:
    runs-on: ubuntu-latest
    steps:

    # --- STEP 1: INITIALIZE & CHECK FOR STOP COMMAND ---
    - name: Check for graceful shutdown signal from previous session
      run: |
        # This would use a GitHub API call or check a known location to see if the 'stop' signal was set.
        # For a real implementation, you would need to implement this logic.
        echo "Checking if a graceful shutdown was requested..."
        # If a stop signal is found from the *previous* run, we skip this session.
        # For now, we simulate no signal found and proceed.
        echo "No signal found. Proceeding with new session."

    # --- STEP 2: PROVISION FRESH VPS (SIMULATED HERE) ---
    - name: Setup Base System
      run: |
        echo "üï∑Ô∏è Provisioning a new VPS instance for $VPS_HOSTNAME..."
        # In a real scenario, this would be API calls to AWS Lightsail, DigitalOcean, etc.
        # We are simulating the environment of a fresh Ubuntu server.

    # --- STEP 3: RESTORE PREVIOUS STATE (PERSISTENCE) ---
    - name: Restore Persistent State
      run: |
        echo "Attempting to restore the previous state..."

        # METHOD 1: Try to download from GitHub Artifacts
        echo "1. Checking GitHub Artifacts..."
        # The 'download-artifact' action is used in a subsequent step.
        # This script would handle the extraction and placement of files.
        # This is a placeholder for the logic that runs after the artifact is downloaded.

        # METHOD 2: If Artifact fails, check the META file for a direct Mega link
        echo "2. GitHub Artifact not found. Checking MEGA backup via meta file..."
        MEGA_BACKUP_URL=$(curl -s -f $META_FILE_URL || echo "")
        if [ ! -z "$MEGA_BACKUP_URL" ]; then
          echo "Mega URL found: $MEGA_BACKUP_URL"
          # Install megatools if needed
          # sudo apt-get install -y megatools
          # megadl --path /tmp/backup.tar.gz "$MEGA_BACKUP_URL"
          echo "Simulating download from Mega: $MEGA_BACKUP_URL"
          touch /tmp/backup.tar.gz # Simulate a downloaded file
        else
          echo "No backup found. This is a fresh start or a catastrophic failure."
          exit 0 # This is not an error; it's just a new start.
        fi

        # Extract the backup (if it was found and downloaded)
        if [ -f "/tmp/backup.tar.gz" ]; then
          echo "Extracting backup to restore user data, apps, and configs..."
          # tar -xzf /tmp/backup.tar.gz -C / --keep-old-files --skip-old-files
          echo "Backup extraction simulated."
        fi
      shell: bash

    # --- ACTUAL DOWNLOAD OF GITHUB ARTIFACT (RUNS SEPARATELY) ---
    - name: Download Artifact from GitHub
      uses: actions/download-artifact@v4
      with:
        name: ${{ env.BACKUP_ARTIFACT_NAME }}
        path: /tmp/
      continue-on-error: true # This is crucial! If artifact doesn't exist, the job continues.

    # --- STEP 4: SYSTEM CONFIGURATION ---
    - name: Configure System and Users
      run: |
        echo "Setting hostname to $VPS_HOSTNAME..."
        sudo hostnamectl set-hostname $VPS_HOSTNAME

        echo "Creating primary user '$SUDO_USER'..."
        # Create user, set password, and add to sudo group
        sudo useradd -m -G sudo -s /bin/bash $SUDO_USER
        echo "$SUDO_USER:$USER_PASSWORD" | sudo chpasswd
        # Set the password to expire never (optional)
        sudo chpasswd -e $SUDO_USER

        # IMPORTANT: From this point, all commands should be run as the new user
        # for user-specific configs, but for simplicity in this simulation, we continue as root.

    # --- STEP 5: INSTALL & CONFIGURE AAPANEL ---
    - name: Install aaPanel
      run: |
        echo "Installing aaPanel (Chinese version)..."
        # The -y flag automates the "yes" response
        wget -O install.sh http://www.aapanel.com/script/install-ubuntu_6.0_en.sh && sudo bash install.sh aapanel
        # After installation, script usually outputs admin URL and password.

        echo "Configuring aaPanel credentials..."
        # This simulates using the 'bt' command to change the panel username and password.
        # The actual commands might vary. This assumes the panel is running.
        # sudo bt 5 <<< "$BT_USERNAME"
        # sudo bt 6 <<< "$BT_PASSWORD"
        echo "Panel username set to $BT_USERNAME"
        echo "Panel password set to $BT_PASSWORD"

    # --- STEP 6: INSTALL & CONFIGURE TAILSCALE ---
    - name: Setup Tailscale
      run: |
        echo "Installing Tailscale..."
        curl -fsSL https://tailscale.com/install.sh | sh
        # You would need to authenticate. Using an auth key from secrets is best.
        # sudo tailscale up --authkey ${{ secrets.TAILSCALE_AUTHKEY }} --hostname $VPS_HOSTNAME
        echo "Tailscale installed. Auth key would be applied from secrets."

    # --- STEP 7: APPLICATION LOGIC & RUNTIME ---
    - name: Run Session Main Process
      run: |
        echo "‚úÖ Session started successfully at $(date)"
        echo "Hostname: $(hostname)"
        echo "User: $SUDO_USER created."
        echo "This session will now run for ~5.5 hours."

        # SIMULATION: This is where your actual application would run.
        # Instead of sleeping, you would run a server, scripts, etc.
        # We use a loop that checks for the stop signal every minute.

        duration=330 # 5.5 hours in minutes
        for (( i=1; i<=duration; i++ )); do
          # Check for the graceful shutdown command file
          if [ -f "/tmp/stop" ]; then
            echo "üõë Graceful shutdown command received. Stopping session..."
            break
          fi
          echo "Session alive... (minute $i/$duration)"
          sleep 60 # Wait for 1 minute
        done

        echo "Session runtime complete."

    # --- STEP 8: GRACEFUL SHUTDOWN & BACKUP ---
    - name: Prepare Backup and Shutdown
      if: always() # Run this step even if a previous step fails
      run: |
        echo "Initiating shutdown sequence..."

        # Check if the stop command was the reason for shutdown
        if [ -f "/tmp/stop" ]; then
          echo "Final backup requested by user."
          sudo rm /tmp/stop # Clean up the signal for the next session
        fi

        echo "Creating backup of important data..."
        # Create a tarball of only crucial directories, excluding the OS.
        # e.g., user home directories, application configs, Tailscale state, aaPanel www data.
        backup_dirs="/home/$SUDO_USER /etc/tailscale /www"
        sudo tar -czf /tmp/backup.tar.gz $backup_dirs 2>/dev/null || echo "Some files were not found, continuing."

        echo "Backup archive created."

    # --- STEP 9: UPLOAD BACKUP TO GITHUB ARTIFACTS ---
    - name: Upload Backup to GitHub Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.BACKUP_ARTIFACT_NAME }}
        path: /tmp/backup.tar.gz
        if-no-files-found: ignore
        retention-days: 1 # Keep only the most recent backup to save space

    # --- STEP 10: UPLOAD BACKUP TO MEGA (FALLBACK) ---
    - name: Upload Backup to MEGA.nz
      run: |
        # Check if the backup file exists and is a valid size
        if [ -f "/tmp/backup.tar.gz" ] && [ -s "/tmp/backup.tar.gz" ]; then
          echo "Uploading backup to MEGA.nz as a fallback..."
          # Install megatools: sudo apt-get install -y megatools
          # Upload the file. The credentials come from the env variable set by the secret.
          # mega-put /tmp/backup.tar.gz /Root/ --username $(echo $MEGA_CREDENTIALS | cut -d: -f1) --password $(echo $MEGA_CREDENTIALS | cut -d: -f2)
          echo "Simulating MEGA upload..."

          # After upload, get the public link and overwrite the meta file in the repo.
          SIMULATED_MEGA_URL="https://mega.nz/file/simulated-link#spidey-backup"
          echo "$SIMULATED_MEGA_URL" > mega_backup_url.txt

          # Use GitHub CLI to commit this URL back to the repository for the next session to find.
          # gh repo clone YourRepo/YourRepo
          # git config user.name "github-actions"
          # git config user.email "github-actions@github.com"
          # git add mega_backup_url.txt
          # git commit -m "Update latest MEGA backup URL"
          # git push
          echo "Meta file updated with simulated URL: $SIMULATED_MEGA_URL"
        else
          echo "Backup file is missing or empty. Skipping MEGA upload."
        fi
      shell: bash

    # --- STEP 11: TERMINATE VPS (SIMULATED) ---
    - name: Terminate VPS Instance
      run: |
        echo "Shutdown complete. Terminating VPS instance..."
        # In a real scenario, this would be an API call to your cloud provider
        # to destroy this current server. The backup is already safe.
        echo "VPS termination simulated. Goodbye!"
