# -----------------------------------------------------------------------------------
# Persistent VPS (Immortal Edition) - FIXED VERSION
#
# v11.0 - Complete rewrite with robust error handling and improved algorithms
# -----------------------------------------------------------------------------------

name: Persistent VPS (Immortal Edition)

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      force_fresh_install:
        description: 'Force fresh installation (ignore backups)'
        required: false
        default: 'false'
        type: boolean
      backup_retention_days:
        description: 'Backup retention days'
        required: false
        default: '7'
        type: string
      session_duration_minutes:
        description: 'Session duration in minutes'
        required: false
        default: '220'
        type: string

env:
  BACKUP_STORE: /tmp/vps-backups
  BACKUP_WORKING_DIR: /tmp/backup-work
  FULL_BACKUP_NAME: vps-full-system-backup.tar.zst
  INCREMENTAL_BACKUP_NAME: vps-incremental-backup.tar.zst
  MEGA_REMOTE: mega:vps-backup

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 235
    permissions:
      contents: read
      actions: write

    steps:
      - name: '🚀 Initialize Environment'
        uses: actions/checkout@v4

      - name: '🔧 Install Enhanced Toolchain'
        run: |
          set -euo pipefail
          echo "Installing enhanced toolchain..."
          
          # Update package lists
          sudo apt-get update -qq
          
          # Install core packages
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            zstd pv rsync jq curl wget psmisc screen tmate \
            htop fail2ban ufw python3-pip tree fuse \
            software-properties-common apt-transport-https ca-certificates \
            gnupg lsb-release
          
          # Install rclone
          curl -fsSL https://rclone.org/install.sh | sudo bash
          
          # Install Python packages
          pip3 install --user psutil requests
          
          # Verify installations
          rclone version
          zstd --version
          pv --version
          
          echo "✅ Enhanced toolchain installed successfully."

      - name: '🔐 Configure Rclone'
        run: |
          set -euo pipefail
          
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "❌ CRITICAL: RCLONE_CONFIG secret is missing!" >&2
            exit 1
          fi
          
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          
          # Test rclone configuration
          if ! rclone listremotes | grep -q "mega:"; then
            echo "❌ CRITICAL: Rclone MEGA remote not configured properly!" >&2
            exit 1
          fi
          
          echo "✅ Rclone configured and tested successfully."

      - name: '🔍 Advanced Backup Discovery'
        id: discover_backup
        run: |
          set -euo pipefail
          echo "🔎 Performing advanced backup discovery..."
          
          BACKUP_FOUND=false
          BACKUP_SOURCE=""
          BACKUP_URL=""
          BACKUP_TYPE=""
          
          # Check for forced fresh install
          if [[ "${{ github.event.inputs.force_fresh_install || 'false' }}" == "true" ]]; then
            echo "🔄 Fresh installation forced by user input."
            echo "backup_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Function to check GitHub artifacts
          check_github_artifacts() {
            local workflow_id latest_run_id artifacts_json
            
            workflow_id=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows" \
              | jq -r '.workflows[] | select(.name == "Persistent VPS (Immortal Edition)") | .id' | head -1)
            
            if [[ -n "$workflow_id" && "$workflow_id" != "null" ]]; then
              latest_run_id=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${workflow_id}/runs?status=success&per_page=10" \
                | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id' | head -1)
              
              if [[ -n "$latest_run_id" && "$latest_run_id" != "null" ]]; then
                artifacts_json=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/${latest_run_id}/artifacts")
                
                # Check for full backup first
                local full_artifact_id
                full_artifact_id=$(echo "$artifacts_json" | jq -r ".artifacts[] | select(.name == \"${{ env.FULL_BACKUP_NAME }}\") | .id")
                if [[ -n "$full_artifact_id" && "$full_artifact_id" != "null" ]]; then
                  BACKUP_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${full_artifact_id}/zip"
                  BACKUP_TYPE="full"
                  BACKUP_SOURCE="github_artifact"
                  return 0
                fi
                
                # Check for incremental backup
                local incr_artifact_id
                incr_artifact_id=$(echo "$artifacts_json" | jq -r ".artifacts[] | select(.name == \"${{ env.INCREMENTAL_BACKUP_NAME }}\") | .id")
                if [[ -n "$incr_artifact_id" && "$incr_artifact_id" != "null" ]]; then
                  BACKUP_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${incr_artifact_id}/zip"
                  BACKUP_TYPE="incremental"
                  BACKUP_SOURCE="github_artifact"
                  return 0
                fi
              fi
            fi
            return 1
          }
          
          # Function to check MEGA backups
          check_mega_backups() {
            if rclone ls "${MEGA_REMOTE}/full_backup_link.txt" >/dev/null 2>&1; then
              BACKUP_URL=$(rclone cat "${MEGA_REMOTE}/full_backup_link.txt")
              BACKUP_TYPE="full"
              BACKUP_SOURCE="mega_link"
              return 0
            elif rclone ls "${MEGA_REMOTE}/incremental_backup_link.txt" >/dev/null 2>&1; then
              BACKUP_URL=$(rclone cat "${MEGA_REMOTE}/incremental_backup_link.txt")
              BACKUP_TYPE="incremental"
              BACKUP_SOURCE="mega_link"
              return 0
            fi
            return 1
          }
          
          # Try GitHub artifacts first, then MEGA
          if check_github_artifacts || check_mega_backups; then
            BACKUP_FOUND=true
          fi
          
          # Output results
          echo "backup_found=$BACKUP_FOUND" >> $GITHUB_OUTPUT
          echo "backup_source=$BACKUP_SOURCE" >> $GITHUB_OUTPUT
          echo "backup_url=$BACKUP_URL" >> $GITHUB_OUTPUT
          echo "backup_type=$BACKUP_TYPE" >> $GITHUB_OUTPUT
          
          if [[ "$BACKUP_FOUND" == "true" ]]; then
            echo "✅ Backup Found: Type=$BACKUP_TYPE, Source=$BACKUP_SOURCE"
          else
            echo "ℹ️ No backups found. Will perform fresh installation."
          fi

      - name: '🔄 Advanced System Restoration'
        if: steps.discover_backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          echo "🚀 Beginning advanced system restoration..."
          
          # Create restore directory with proper permissions
          sudo mkdir -p /mnt/restore
          cd /mnt/restore
          
          # Download backup with retry logic
          download_backup() {
            local url="$1"
            local max_attempts=5
            local attempt=1
            
            while [[ $attempt -le $max_attempts ]]; do
              echo "Download attempt $attempt/$max_attempts..."
              
              if timeout 900 curl --retry 3 --retry-delay 30 -L \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github+json" \
                "$url" -o "backup.zip"; then
                return 0
              fi
              
              echo "Download attempt $attempt failed."
              ((attempt++))
              sleep 60
            done
            
            echo "❌ All download attempts failed!" >&2
            return 1
          }
          
          # Download and extract backup
          if ! download_backup "${{ steps.discover_backup.outputs.backup_url }}"; then
            echo "❌ Failed to download backup!" >&2
            exit 1
          fi
          
          # Verify and extract zip file
          if ! unzip -t backup.zip >/dev/null 2>&1; then
            echo "❌ Downloaded backup.zip is corrupted!" >&2
            exit 1
          fi
          
          sudo unzip -q backup.zip
          
          # Find and verify backup file
          BACKUP_FILE=$(find . -name "*.tar.zst" -type f | head -1)
          if [[ ! -f "$BACKUP_FILE" ]]; then
            echo "❌ No backup file found in archive!" >&2
            exit 1
          fi
          
          # Verify backup integrity
          if ! zstd -t "$BACKUP_FILE"; then
            echo "❌ Backup file is corrupted!" >&2
            exit 1
          fi
          
          echo "✅ Backup verified (Size: $(du -h "$BACKUP_FILE" | cut -f1))"
          
          # Create exclusion list for restoration
          cat > /tmp/restore_excludes.txt << 'EOF'
          ./proc/*
          ./sys/*
          ./dev/*
          ./run/*
          ./tmp/*
          ./mnt/*
          ./home/runner/*
          ./github/*
          EOF
          
          # Perform restoration with progress bar
          echo "🔄 Restoring system... This may take several minutes."
          if [[ "${{ steps.discover_backup.outputs.backup_type }}" == "full" ]]; then
            pv "$BACKUP_FILE" | sudo tar -I zstd -xpf - -C / --exclude-from=/tmp/restore_excludes.txt
          else
            # For incremental backups, be more careful
            pv "$BACKUP_FILE" | sudo tar -I zstd -xpf - -C / --exclude-from=/tmp/restore_excludes.txt --keep-newer-files
          fi
          
          # Cleanup
          sudo rm -rf /mnt/restore /tmp/restore_excludes.txt
          
          echo "✅ System restoration completed successfully."

      - name: '🛠️ Post-Restoration System Repair'
        if: steps.discover_backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          echo "🔧 Performing comprehensive post-restoration system repair..."
          
          # Update package database
          sudo apt-get update -qq || echo "⚠️ Package update failed, continuing..."
          
          # Repair and reinstall critical services
          repair_service() {
            local service="$1"
            local package="$2"
            
            echo "Repairing $service..."
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --reinstall "$package" || \
              echo "⚠️ Failed to reinstall $package"
            
            sudo systemctl daemon-reload
            sudo systemctl enable "$service" 2>/dev/null || echo "⚠️ Could not enable $service"
            sudo systemctl restart "$service" 2>/dev/null || echo "⚠️ Could not restart $service"
          }
          
          # Install Docker if not present
          if ! command -v docker >/dev/null 2>&1; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker "$USER" 2>/dev/null || true
          fi
          
          # Repair essential services
          repair_service "ssh" "openssh-server"
          repair_service "docker" "docker-ce"
          repair_service "mariadb" "mariadb-server"
          repair_service "fail2ban" "fail2ban"
          
          # Fix MySQL/MariaDB permissions if database exists
          if [[ -d "/var/lib/mysql" ]]; then
            echo "Fixing MySQL/MariaDB permissions..."
            sudo chown -R mysql:mysql /var/lib/mysql
            sudo chmod 755 /var/lib/mysql
            sudo systemctl restart mariadb 2>/dev/null || echo "⚠️ Could not restart mariadb"
          fi
          
          # Restart aaPanel if present
          if [[ -f "/www/server/panel/init.sh" ]]; then
            echo "Restarting aaPanel..."
            sudo /www/server/panel/init.sh restart || echo "⚠️ Could not restart aaPanel"
          fi
          
          # Fix common permission issues
          sudo chmod 755 /usr/local/bin/* 2>/dev/null || true
          sudo chmod +x /etc/init.d/* 2>/dev/null || true
          
          echo "✅ Post-restoration system repair completed."

      - name: '🆕 Enhanced Fresh Installation'
        if: steps.discover_backup.outputs.backup_found == 'false'
        run: |
          set -euo pipefail
          echo "🚀 Performing enhanced fresh installation..."
          
          # Install Docker
          if ! command -v docker >/dev/null 2>&1; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker "$USER"
          fi
          
          # Install essential services
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            mariadb-server fail2ban ufw openssh-server \
            nginx redis-server
          
          # Install aaPanel with timeout and error handling
          install_aapanel() {
            local install_script="/tmp/install_aapanel.sh"
            
            if curl -fsSL -o "$install_script" "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"; then
              chmod +x "$install_script"
              timeout 1800 bash -c "printf 'y\nyes\n' | sudo bash $install_script" || {
                echo "⚠️ aaPanel installation timed out or failed. Continuing without aaPanel."
                return 1
              }
            else
              echo "⚠️ Could not download aaPanel installer. Continuing without aaPanel."
              return 1
            fi
          }
          
          install_aapanel || echo "⚠️ aaPanel installation skipped due to errors."
          
          echo "✅ Fresh installation completed successfully."

      - name: '🔐 Enhanced Security & User Setup'
        if: steps.discover_backup.outputs.backup_found == 'false'
        run: |
          set -euo pipefail
          echo "🔐 Setting up enhanced security and user credentials..."
          
          # Create user with proper error handling
          if ! id "jacky" >/dev/null 2>&1; then
            sudo useradd -m -s /bin/bash -G sudo jacky
            echo "✅ User 'jacky' created."
          else
            echo "ℹ️ User 'jacky' already exists."
          fi
          
          # Set user password
          if [[ -n "${{ secrets.USER_PASSWORD || '' }}" ]]; then
            echo "jacky:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
            echo "jacky ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/jacky
            echo "✅ User password configured."
          else
            echo "⚠️ USER_PASSWORD secret not set."
          fi
          
          # Add user to docker group if docker exists
          if command -v docker >/dev/null 2>&1; then
            sudo usermod -aG docker jacky
            echo "✅ User added to docker group."
          fi
          
          # Configure MariaDB root password
          if systemctl is-active --quiet mariadb && [[ -n "${{ secrets.DB_ROOT_PASSWORD || '' }}" ]]; then
            sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD('${{ secrets.DB_ROOT_PASSWORD }}'); FLUSH PRIVILEGES;" || \
              echo "⚠️ Could not set MariaDB root password."
            echo "✅ MariaDB root password configured."
          fi
          
          # Configure aaPanel if present
          if [[ -f "/www/server/panel/init.sh" ]]; then
            echo "Configuring aaPanel..."
            timeout 30 bash -c 'echo "Jacky" | sudo bt 6' || echo "⚠️ Could not set aaPanel username"
            timeout 30 bash -c 'echo "spidey" | sudo bt 5' || echo "⚠️ Could not set aaPanel password"
            echo "✅ aaPanel configured."
          fi
          
          # Configure firewall
          echo "Configuring UFW firewall..."
          sudo ufw --force reset
          sudo ufw default deny incoming
          sudo ufw default allow outgoing
          sudo ufw allow ssh
          sudo ufw allow http
          sudo ufw allow https
          sudo ufw allow 8888/tcp  # aaPanel
          sudo ufw allow 21/tcp    # FTP
          sudo ufw allow 3306/tcp  # MySQL
          sudo ufw --force enable
          echo "✅ Firewall configured."
          
          # Enable and start services
          for service in fail2ban ssh mariadb docker redis-server nginx; do
            if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
              sudo systemctl enable --now "$service" 2>/dev/null || \
                echo "⚠️ Could not enable/start $service"
            fi
          done
          
          echo "✅ Security setup completed successfully."

      - name: '🌐 Configure Network Access'
        run: |
          set -euo pipefail
          echo "🌐 Setting up network access..."
          
          # Install Tailscale
          if ! command -v tailscale >/dev/null 2>&1; then
            curl -fsSL https://tailscale.com/install.sh | sh
            echo "✅ Tailscale installed."
          fi
          
          # Configure Tailscale
          if [[ -n "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
            if [[ -f "/var/lib/tailscale/tailscaled.state" ]]; then
              echo "Tailscale already configured, bringing up..."
              sudo systemctl enable --now tailscaled
              sudo tailscale up --accept-routes || echo "⚠️ Could not bring up existing Tailscale"
            else
              echo "Configuring new Tailscale connection..."
              sudo systemctl enable --now tailscaled
              sudo tailscale up \
                --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" \
                --hostname="github-vps-immortal-$(date +%s)" \
                --reset \
                --accept-routes || echo "⚠️ Could not configure new Tailscale"
            fi
          else
            echo "⚠️ TAILSCALE_AUTHKEY not provided, skipping Tailscale setup."
          fi
          
          # Setup tmate for SSH access
          echo "Setting up tmate SSH session..."
          tmate -S /tmp/tmate.sock new-session -d
          
          # Wait for tmate to be ready
          timeout 60 bash -c 'while ! tmate -S /tmp/tmate.sock wait tmate-ready; do sleep 1; done' || \
            echo "⚠️ tmate setup timed out"
          
          # Display connection information
          echo ""
          echo "================================================="
          echo "🎉      IMMORTAL VPS IS READY FOR CONNECTION      🎉"
          echo "================================================="
          
          if command -v tailscale >/dev/null 2>&1; then
            TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null || echo "Not available")
            echo "🌐 Tailscale IP: $TAILSCALE_IP"
          fi
          
          if tmate -S /tmp/tmate.sock list-sessions >/dev/null 2>&1; then
            TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo "Not available")
            echo "🔑 tmate SSH:    $TMATE_SSH"
          fi
          
          # Display aaPanel info if available
          if [[ -f "/www/server/panel/init.sh" ]]; then
            echo ""
            echo "📊 aaPanel Information:"
            sudo bt default || echo "   Could not retrieve aaPanel info"
          fi
          
          echo "================================================="

      - name: '⏳ Enhanced Session Maintenance'
        run: |
          set -euo pipefail
          echo "⏳ Starting enhanced session maintenance..."
          
          # Session duration from input or default
          SESSION_DURATION_MINUTES=${{ github.event.inputs.session_duration_minutes || '220' }}
          SESSION_DURATION_SECONDS=$((SESSION_DURATION_MINUTES * 60))
          
          # Logging function
          log_message() { 
            echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
          }
          
          # Create advanced session keeper script
          cat << 'SCRIPT_EOF' > /tmp/session_keeper.sh
          #!/bin/bash
          
          log_message() { 
            echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
          }
          
          # Service monitoring and recovery
          monitor_services() {
            local services=("ssh" "tailscaled")
            
            # Add docker to monitoring if it exists
            if systemctl list-unit-files --type=service | grep -q "^docker\.service"; then
              services+=("docker")
            fi
            
            # Add mariadb to monitoring if it exists
            if systemctl list-unit-files --type=service | grep -q "^mariadb\.service"; then
              services+=("mariadb")
            fi
            
            for service in "${services[@]}"; do
              if systemctl is-enabled --quiet "$service" 2>/dev/null; then
                if ! systemctl is-active --quiet "$service"; then
                  log_message "⚠️ $service service is down, attempting restart..."
                  if sudo systemctl restart "$service"; then
                    log_message "✅ $service service restarted successfully"
                  else
                    log_message "❌ Failed to restart $service service"
                  fi
                fi
              fi
            done
          }
          
          # tmate session monitoring
          monitor_tmate() {
            if ! tmate -S /tmp/tmate.sock list-sessions >/dev/null 2>&1; then
              log_message "⚠️ tmate session lost, attempting restart..."
              tmate -S /tmp/tmate.sock new-session -d
              sleep 5
              if tmate -S /tmp/tmate.sock wait tmate-ready; then
                log_message "✅ tmate session restarted successfully"
                log_message "🔑 New tmate SSH: $(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo 'Not available')"
              else
                log_message "❌ Failed to restart tmate session"
              fi
            fi
          }
          
          # System health monitoring
          monitor_system_health() {
            local load_avg disk_usage memory_usage
            
            load_avg=$(uptime | awk -F'load average:' '{ print $2 }' | cut -d, -f1 | xargs)
            disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
            memory_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
            
            if (( $(echo "$load_avg > 10" | bc -l) )); then
              log_message "⚠️ High system load: $load_avg"
            fi
            
            if (( disk_usage > 85 )); then
              log_message "⚠️ High disk usage: ${disk_usage}%"
            fi
            
            if (( memory_usage > 90 )); then
              log_message "⚠️ High memory usage: ${memory_usage}%"
            fi
          }
          
          # Main monitoring loop
          while true; do
            monitor_services
            monitor_tmate
            monitor_system_health
            sleep 300  # Check every 5 minutes
          done
          SCRIPT_EOF
          
          chmod +x /tmp/session_keeper.sh
          
          # Start session keeper in background
          nohup bash /tmp/session_keeper.sh > /tmp/session_keeper.log 2>&1 &
          KEEPER_PID=$!
          
          log_message "🖥️ Session maintenance started (PID: $KEEPER_PID)"
          log_message "📊 Session will run for $SESSION_DURATION_MINUTES minutes"
          log_message "🛑 To shutdown early, create file: touch /tmp/stop"
          
          # Main session loop
          END_TIME=$((SECONDS + SESSION_DURATION_SECONDS))
          CHECK_INTERVAL=60
          
          while [ $SECONDS -lt $END_TIME ]; do
            # Check for early termination signal
            if [ -f "/tmp/stop" ]; then
              log_message "✅ Graceful shutdown signal detected."
              sudo rm -f "/tmp/stop"
              break
            fi
            
            # Display periodic status updates
            REMAINING_MINUTES=$(( (END_TIME - SECONDS) / 60 ))
            if (( SECONDS % 1800 == 0 )); then  # Every 30 minutes
              log_message "📊 Session status: ${REMAINING_MINUTES} minutes remaining"
              
              # Display system info
              log_message "💾 Disk usage: $(df -h / | awk 'NR==2 {print $5}')"
              log_message "🧠 Memory usage: $(free -h | awk 'NR==2{printf "%.1f%", $3*100/$2}')"
              log_message "⚡ Load average: $(uptime | awk -F'load average:' '{print $2}')"
            fi
            
            sleep $CHECK_INTERVAL
          done
          
          # Cleanup session keeper
          if kill -0 $KEEPER_PID 2>/dev/null; then
            kill $KEEPER_PID
            log_message "🧹 Session keeper stopped"
          fi
          
          log_message "⏰ Session maintenance concluded. Proceeding to backup phase."

      - name: '📦 Create Intelligent Multi-Layer Backup'
        id: create_backup
        if: always()
        run: |
          set -euo pipefail
          echo "📦 Creating intelligent multi-layer backup..."
          
          # Create backup directories
          mkdir -p "${{ env.BACKUP_STORE }}" "${{ env.BACKUP_WORKING_DIR }}"
          
          # Determine backup strategy
          BACKUP_STRATEGY="full"
          if [[ "${{ steps.discover_backup.outputs.backup_found }}" == "true" && "${{ steps.discover_backup.outputs.backup_type }}" == "full" ]]; then
            BACKUP_STRATEGY="incremental"
          fi
          
          echo "📋 Backup strategy: $BACKUP_STRATEGY"
          
          # Gracefully stop services for consistent backup
          stop_services_gracefully() {
            local services_to_stop=()
            
            # Stop aaPanel if present
            if [[ -f "/www/server/panel/init.sh" ]]; then
              echo "Stopping aaPanel..."
              sudo /www/server/panel/init.sh stop || echo "⚠️ Could not stop aaPanel"
            fi
            
            # Stop database services for consistency
            if systemctl is-active --quiet mariadb; then
              echo "Stopping MariaDB..."
              sudo systemctl stop mariadb || echo "⚠️ Could not stop MariaDB"
              services_to_stop+=("mariadb")
            fi
            
            if systemctl is-active --quiet mysql; then
              echo "Stopping MySQL..."
              sudo systemctl stop mysql || echo "⚠️ Could not stop MySQL"
              services_to_stop+=("mysql")
            fi
            
            # Wait a moment for services to fully stop
            sleep 5
            
            echo "${services_to_stop[@]}" > /tmp/stopped_services.txt
          }
          
          stop_services_gracefully
          
          # Create comprehensive exclusion list
          cat > /tmp/backup_excludes.txt << 'EOF'
          ./proc/*
          ./sys/*
          ./dev/*
          ./run/*
          ./tmp/tmate.sock
          ./tmp/session_keeper.log
          ./tmp/backup_excludes.txt
          ./tmp/stopped_services.txt
          ./home/runner/*
          ./github/*
          ./mnt/*
          ./var/cache/apt/archives/*
          ./var/log/journal/*
          ./var/tmp/*
          ./root/.cache/*
          ./swapfile
          ./swap.img
          EOF
          
          # Set backup file paths
          if [[ "$BACKUP_STRATEGY" == "full" ]]; then
            BACKUP_FILE="${{ env.BACKUP_STORE }}/${{ env.FULL_BACKUP_NAME }}"
            ARTIFACT_NAME="${{ env.FULL_BACKUP_NAME }}"
            
            echo "Creating full system backup..."
            sudo tar -cf - \
              --absolute-names \
              --directory=/ \
              --exclude-from=/tmp/backup_excludes.txt \
              --warning=no-file-changed \
              --warning=no-file-removed \
              . | zstd -T0 -3 -q > "$BACKUP_FILE"
            
          else
            BACKUP_FILE="${{ env.BACKUP_STORE }}/${{ env.INCREMENTAL_BACKUP_NAME }}"
            ARTIFACT_NAME="${{ env.INCREMENTAL_BACKUP_NAME }}"
            
            echo "Creating incremental backup (changes since 4 hours ago)..."
            sudo tar -cf - \
              --absolute-names \
              --directory=/ \
              --exclude-from=/tmp/backup_excludes.txt \
              --newer-mtime='4 hours ago' \
              --warning=no-file-changed \
              --warning=no-file-removed \
              . | zstd -T0 -3 -q > "$BACKUP_FILE"
          fi
          
          # Verify backup creation
          if [[ ! -f "$BACKUP_FILE" ]]; then
            echo "❌ Primary backup creation failed! Creating emergency backup..."
            
            # Create emergency backup with essential files only
            BACKUP_FILE="${{ env.BACKUP_STORE }}/emergency-backup.tar.zst"
            ARTIFACT_NAME="emergency-backup.tar.zst"
            
            sudo tar -cf - \
              /etc \
              /root \
              /home \
              /var/www \
              /usr/local \
              2>/dev/null | zstd -T0 -1 -q > "$BACKUP_FILE" || {
              echo "❌ Emergency backup also failed! Creating minimal backup..."
              
              # Last resort: create minimal backup
              sudo tar -cf - /etc/passwd /etc/group /etc/shadow /etc/hosts 2>/dev/null | \
                zstd -T0 -1 -q > "$BACKUP_FILE"
              echo "⚠️ Only minimal system backup created"
            }
          fi
          
          # Verify final backup
          if [[ ! -f "$BACKUP_FILE" ]] || [[ ! -s "$BACKUP_FILE" ]]; then
            echo "❌ All backup attempts failed!" >&2
            exit 1
          fi
          
          # Test backup integrity
          if ! zstd -t "$BACKUP_FILE" 2>/dev/null; then
            echo "❌ Backup file is corrupted!" >&2
            exit 1
          fi
          
          BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
          echo "✅ Backup created successfully (Size: $BACKUP_SIZE, Strategy: $BACKUP_STRATEGY)"
          
          # Restart stopped services
          if [[ -f /tmp/stopped_services.txt ]]; then
            while read -r service; do
              if [[ -n "$service" ]]; then
                echo "Restarting $service..."
                sudo systemctl start "$service" || echo "⚠️ Could not restart $service"
              fi
            done < /tmp/stopped_services.txt
          fi
          
          # Restart aaPanel if it was running
          if [[ -f "/www/server/panel/init.sh" ]]; then
            echo "Restarting aaPanel..."
            sudo /www/server/panel/init.sh start || echo "⚠️ Could not restart aaPanel"
          fi
          
          # Output results
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "backup_strategy=$BACKUP_STRATEGY" >> $GITHUB_OUTPUT
          echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT

      - name: '⬆️ Upload Backup as Artifact'
        if: always() && steps.create_backup.outputs.backup_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_backup.outputs.artifact_name }}
          path: ${{ steps.create_backup.outputs.backup_file }}
          retention-days: ${{ github.event.inputs.backup_retention_days || '7' }}
          if-no-files-found: error
          compression-level: 0  # Already compressed with zstd

      - name: '🔗 Store Backup Link in MEGA'
        if: always() && steps.create_backup.outputs.backup_file != ''
        run: |
          set -euo pipefail
          echo "🔗 Storing backup link in MEGA cloud storage..."
          
          ARTIFACT_NAME="${{ steps.create_backup.outputs.artifact_name }}"
          BACKUP_STRATEGY="${{ steps.create_backup.outputs.backup_strategy }}"
          BACKUP_SIZE="${{ steps.create_backup.outputs.backup_size }}"
          
          # Wait for artifact to be uploaded and available
          echo "⏳ Waiting for artifact to be available..."
          sleep 60
          
          # Function to get artifact ID with retries
          get_artifact_id() {
            local max_attempts=20
            local attempt=1
            local artifact_id
            
            while [[ $attempt -le $max_attempts ]]; do
              echo "Attempt $attempt/$max_attempts: Retrieving artifact ID..."
              
              artifact_id=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
                | jq -r ".artifacts[] | select(.name == \"$ARTIFACT_NAME\") | .id")
              
              if [[ -n "$artifact_id" && "$artifact_id" != "null" ]]; then
                echo "$artifact_id"
                return 0
              fi
              
              echo "Artifact not found yet, waiting..."
              sleep 30
              ((attempt++))
            done
            
            echo "Failed to get artifact ID after $max_attempts attempts" >&2
            return 1
          }
          
          # Function for direct backup upload as fallback
          direct_backup_upload() {
            echo "🔄 Using fallback: Direct backup upload to MEGA..."
            
            local backup_file="${{ steps.create_backup.outputs.backup_file }}"
            local timestamp=$(date +%Y%m%d_%H%M%S)
            local mega_path="${MEGA_REMOTE}/direct-backups/${timestamp}_${ARTIFACT_NAME}"
            
            if rclone copy "$backup_file" "$mega_path"; then
              echo "✅ Backup uploaded directly to MEGA: $mega_path"
              
              # Store direct backup info
              echo "Direct backup: $mega_path (Size: $BACKUP_SIZE)" | \
                rclone rcat "${MEGA_REMOTE}/direct_backup_info.txt"
              
              return 0
            else
              echo "❌ Direct upload to MEGA also failed!" >&2
              return 1
            fi
          }
          
          # Try to get artifact ID
          if ARTIFACT_ID=$(get_artifact_id); then
            echo "✅ Found artifact ID: $ARTIFACT_ID"
            
            # Create artifact download link
            ARTIFACT_LINK="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
            
            # Determine which link file to use
            if [[ "$BACKUP_STRATEGY" == "full" ]]; then
              REMOTE_LINK_FILE="full_backup_link.txt"
              # Remove old incremental backup link when we have a new full backup
              rclone delete "${MEGA_REMOTE}/incremental_backup_link.txt" 2>/dev/null || true
            else
              REMOTE_LINK_FILE="incremental_backup_link.txt"
            fi
            
            # Store link in MEGA with metadata
            cat << EOF | rclone rcat "${MEGA_REMOTE}/${REMOTE_LINK_FILE}"
           $ARTIFACT_LINK
           Backup Type: $BACKUP_STRATEGY
           Backup Size: $BACKUP_SIZE
          Created: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          Run ID: ${{ github.run_id }}
          EOF
            
            echo "✅ Backup link stored in MEGA: ${REMOTE_LINK_FILE}"
            echo "📊 Backup metadata: Type=$BACKUP_STRATEGY, Size=$BACKUP_SIZE"
            
          else
            echo "⚠️ Could not retrieve artifact ID, trying direct upload..."
            if ! direct_backup_upload; then
              echo "❌ All backup storage methods failed!" >&2
              exit 1
            fi
          fi
          
          # Store backup history
          HISTORY_ENTRY="$(date -u '+%Y-%m-%d %H:%M:%S UTC') - $BACKUP_STRATEGY backup (Size: $BACKUP_SIZE, Run: ${{ github.run_id }})"
          echo "$HISTORY_ENTRY" | rclone rcat "${MEGA_REMOTE}/backup_history.log" --append
          
          echo "✅ Backup link storage completed successfully."

      - name: '🧹 Enhanced Cleanup'
        if: always()
        run: |
          set -euo pipefail
          echo "🧹 Performing enhanced cleanup..."
          
          # Clean up temporary files and directories
          cleanup_paths=(
            "/tmp/tmate.sock"
            "/tmp/session_keeper.sh"
            "/tmp/session_keeper.log"
            "/tmp/backup_excludes.txt"
            "/tmp/stopped_services.txt"
            "/tmp/restore_excludes.txt"
            "/mnt/restore"
            "${{ env.BACKUP_WORKING_DIR }}"
          )
          
          for path in "${cleanup_paths[@]}"; do
            if [[ -e "$path" ]]; then
              sudo rm -rf "$path"
              echo "Cleaned: $path"
            fi
          done
          
          # Clean up old log files
          find /tmp -name "*.log" -mtime +1 -delete 2>/dev/null || true
          
          # Clean package cache
          sudo apt-get autoremove -y 2>/dev/null || true
          sudo apt-get autoclean 2>/dev/null || true
          
          # Clean up old backups in backup store (keep only current)
          if [[ -d "${{ env.BACKUP_STORE }}" ]]; then
            find "${{ env.BACKUP_STORE }}" -name "*.tar.zst" -not -name "${{ steps.create_backup.outputs.artifact_name || 'none' }}" -delete 2>/dev/null || true
          fi
          
          echo "✅ Enhanced cleanup completed."

      - name: '📊 Final Status Report'
        if: always()
        run: |
          echo ""
          echo "================================================="
          echo "🎯           FINAL STATUS REPORT              🎯"
          echo "================================================="
          echo "🕐 Session Duration: ${{ github.event.inputs.session_duration_minutes || '220' }} minutes"
          echo "💾 Backup Strategy: ${{ steps.create_backup.outputs.backup_strategy || 'N/A' }}"
          echo "📦 Backup Size: ${{ steps.create_backup.outputs.backup_size || 'N/A' }}"
          echo "🔍 Previous Backup Found: ${{ steps.discover_backup.outputs.backup_found || 'false' }}"
          echo "📅 Run ID: ${{ github.run_id }}"
          echo "🌟 Workflow: ${{ github.workflow }}"
          echo "================================================="
          
          # Display system information
          echo "💻 System Information:"
          echo "   OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
          echo "   Kernel: $(uname -r)"
          echo "   Uptime: $(uptime -p)"
          echo "   Load: $(uptime | awk -F'load average:' '{print $2}')"
          
          # Display service status
          echo ""
          echo "🔧 Key Services Status:"
          for service in ssh docker mariadb tailscaled fail2ban ufw; do
            if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
              if systemctl is-active --quiet "$service"; then
                echo "   ✅ $service: Running"
              else
                echo "   ❌ $service: Stopped"
              fi
            else
              echo "   ➖ $service: Not installed"
            fi
          done
          
          echo ""
          echo "🎉 Immortal VPS session completed successfully!"
          echo "================================================="
