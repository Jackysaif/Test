

name: Persistent VPS (Immortal Edition)

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

env:
  # Using /mnt for more space for the large backup file
  BACKUP_STORE: /mnt/vps-backups
  # This is a full system backup
  BACKUP_NAME: vps-full-system-backup.tar.gz
  MEGA_REMOTE: mega:vps-backup

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 350
    permissions:
      contents: read
      actions: write # Required for artifact interaction

    steps:
      - name: 'ðŸ•¸ï¸ Checkout Code'
        uses: actions/checkout@v4

      - name: 'ðŸ”§ Install Core Tools & Rclone'
        run: |
          set -euo pipefail
          sudo apt-get update -qq
          curl -fsSL https://rclone.org/install.sh | sudo bash
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            tar gzip tmate jq curl psmisc screen
          echo "âœ… Core tools installed."

      - name: 'ðŸ› ï¸ Configure Rclone'
        run: |
          set -euo pipefail
          echo "ðŸ” Setting up rclone configuration..."
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "âŒ ERROR: RCLONE_CONFIG secret is missing!" >&2
            exit 1
          fi
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          echo "âœ… Rclone configured successfully."

      - name: 'ðŸ” Check for Backup (Artifact First, then MEGA)'
        id: check_backup
        run: |
          set -euo pipefail
          echo "ðŸ”Ž Checking for existing backup..."
          ARTIFACT_URL=""
          # Method 1: Search recent successful runs for a backup artifact. THIS IS THE PRIMARY METHOD.
          echo "ðŸ” Searching recent workflow runs for artifacts..."
          WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows" \
            | jq -r '.workflows[] | select(.name == "Persistent VPS (Immortal Edition)") | .id' | head -1)
          if [[ -n "$WORKFLOW_ID" && "$WORKFLOW_ID" != "null" ]]; then
            LATEST_RUN_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs?status=success&per_page=3" \
              | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id' | head -1)
            if [[ -n "$LATEST_RUN_ID" && "$LATEST_RUN_ID" != "null" ]]; then
              ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/${LATEST_RUN_ID}/artifacts" \
                | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')
              if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
                ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
                echo "âœ… Found backup in a recent successful run!"
              fi
            fi
          fi
          # Method 2: If no artifact was found, check MEGA for a fallback link. THIS IS THE SECONDARY METHOD.
          if [[ -z "$ARTIFACT_URL" ]]; then
            echo "â„¹ï¸ No recent artifact found. Checking MEGA for a backup link..."
            if rclone ls "${MEGA_REMOTE}/latest_backup_link.txt" >/dev/null 2>&1; then
              ARTIFACT_URL=$(rclone cat "${MEGA_REMOTE}/latest_backup_link.txt")
              echo "âœ… Found fallback backup link in MEGA!"
            fi
          fi
          # Final Decision
          if [[ -n "$ARTIFACT_URL" ]]; then
            echo "has_backup=true" >> $GITHUB_OUTPUT
            echo "artifact_url=${ARTIFACT_URL}" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No backup found anywhere. This will be a fresh session."
            echo "has_backup=false" >> $GITHUB_OUTPUT
          fi
          
      # ------------------------------------------------------------------
      # Branch 1: Restore Path (if a backup was found)
      # ------------------------------------------------------------------

      - name: 'â™»ï¸ Download & Restore Full System Backup'
        if: steps.check_backup.outputs.has_backup == 'true'
        run: |
          set -euo pipefail
          echo "ðŸ“¥ Downloading full system backup..."
          sudo mkdir -p /mnt/restore
          cd /mnt/restore
          sudo curl --retry 5 --retry-delay 10 -L \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${{ steps.check_backup.outputs.artifact_url }}" \
            -o "backup.zip"
          echo "ðŸ“¦ Extracting ZIP archive..."
          sudo unzip -q backup.zip
          echo "ðŸ“‚ Restoring entire system state from tarball. This will take time..."
          sudo tar -xzpf "${{ env.BACKUP_NAME }}" -C /
          sudo rm -rf /mnt/restore
          echo "âœ… Full system restoration complete."

      - name: 'ðŸ› ï¸ Repair System & Start All Services (Post-Restore)'
        if: steps.check_backup.outputs.has_backup == 'true'
        run: |
          set -euo pipefail
          echo "ðŸ”„ Repairing core system packages and services after full restore..."
          # This step is CRITICAL. It fixes conflicts caused by the full restore.
          sudo apt-get update -qq
          sudo apt-get install -y --reinstall docker-ce mariadb-server openssh-server
          
          echo "âš™ï¸ Reloading services and fixing permissions..."
          sudo chown -R mysql:mysql /var/lib/mysql
          sudo systemctl daemon-reload
          sudo systemctl restart docker
          sudo systemctl restart mariadb
          sudo systemctl restart ssh
          
          echo "ðŸš€ Starting restored Aapanel and all managed services..."
          # Aapanel is already installed from the backup, we just need to start it.
          if [ -f "/www/server/panel/init.sh" ]; then
            sudo /www/server/panel/init.sh start
            sleep 5
            sudo /www/server/panel/init.sh restart
          else
            echo "âŒ CRITICAL: Aapanel was not found after restore!"
          fi
          
          echo "ðŸ“Š Final Service Status Check:"
          sudo bt status

      # ------------------------------------------------------------------
      # Branch 2: Fresh Install Path (if no backup was found)
      # ------------------------------------------------------------------

      - name: 'ðŸ“¦ Install All Applications (Fresh Install)'
        if: steps.check_backup.outputs.has_backup == 'false'
        run: |
          set -euo pipefail
          echo "ðŸš€ Performing first-time setup for all applications..."
          curl -fsSL https://get.docker.com | sudo sh
          sudo apt-get install -y mariadb-server mariadb-client openssh-server
          curl -fsSL -o /tmp/install.sh "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"
          timeout 900 bash -c "printf 'y\nyes\n' | sudo bash /tmp/install.sh" || echo "âš ï¸ Aapanel install timed out."
          sudo systemctl enable --now ssh mariadb docker

      - name: 'ðŸ” Set Initial Credentials (Fresh Install)'
        if: steps.check_backup.outputs.has_backup == 'false'
        run: |
          set -euo pipefail
          echo "ðŸ‘¤ Setting up initial user, passwords, and credentials..."
          sudo useradd -m -s /bin/bash jacky || echo "User exists."
          echo "jacky:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
          sudo usermod -aG sudo,docker jacky
          echo "jacky ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/jacky
          sudo hostnamectl set-hostname github-vps
          echo "127.0.1.1 github-vps" | sudo tee -a /etc/hosts
          
          echo "ðŸ”’ Securing MariaDB and setting Aapanel credentials..."
          if [[ -z "${{ secrets.DB_ROOT_PASSWORD || '' }}" ]]; then
            echo "âŒ ERROR: DB_ROOT_PASSWORD secret is not set!" >&2; exit 1
          fi
          sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD('${{ secrets.DB_ROOT_PASSWORD }}'); FLUSH PRIVILEGES;"
          
          # Set Aapanel creds
          echo "Jacky" | sudo bt 6
          echo "spidey" | sudo bt 5
          echo "âœ… Initial setup and credentials complete."

      # ------------------------------------------------------------------
      # Main Path: Remote Access & Session (Runs for both branches)
      # ------------------------------------------------------------------

      - name: 'ðŸ”— Configure Remote Access with Persistent Tailscale IP'
        run: |
          set -euo pipefail
          echo "ðŸ•¸ï¸ Setting up Tailscale VPN..."
          curl -fsSL https://tailscale.com/install.sh | sh
          if [ -f "/var/lib/tailscale/tailscaled.state" ]; then
            echo "âœ… Tailscale state file found! Restoring persistent session."
            sudo systemctl enable --now tailscaled
            sudo tailscale up --accept-routes
          else
            echo "â„¹ï¸ No Tailscale state found. Performing fresh setup..."
            if [[ -z "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
              echo "âŒ ERROR: TAILSCALE_AUTHKEY is missing!" >&2; exit 1
            fi
            sudo systemctl enable --now tailscaled
            sudo tailscale up --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" --hostname=github-vps --reset --accept-routes
          fi
          echo "ðŸ’¬ Starting tmate..."
          tmate -S /tmp/tmate.sock new-session -d
          tmate -S /tmp/tmate.sock wait tmate-ready
          echo "================================================"
          echo "ðŸŽ‰          VPS IS READY FOR CONNECTION         ðŸŽ‰"
          echo "================================================"
          TAILSCALE_IP=$(sudo tailscale ip -4)
          echo "ðŸŒ Tailscale IP: $TAILSCALE_IP"
          echo "ðŸ”‘ tmate SSH:    $(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')"
          echo ""; sudo bt default || true
          echo "================================================"

      - name: 'â³ Maintain Session'
        run: |
          echo "ðŸ–¥ï¸ VPS session running. Will time out after ~5.5 hours."
          end_time=$((SECONDS + 19800))
          while [ $SECONDS -lt $end_time ]; do sleep 60; done

      # ------------------------------------------------------------------
      # Final Step: Create Full System Backup
      # ------------------------------------------------------------------
      
      - name: 'ðŸ“¦ Create Full System Backup'
        if: always()
        run: |
          set -euo pipefail
          echo "ðŸ“¦ Creating full system backup for perfect state capture..."
          sudo mkdir -p "${{ env.BACKUP_STORE }}"
          echo "ðŸ›‘ Stopping services for a clean backup..."
          if [ -f "/www/server/panel/init.sh" ]; then sudo /www/server/panel/init.sh stop; fi
          sudo systemctl stop mariadb docker tailscaled || true
          
          echo "Creating archive of the entire filesystem..."
          sudo tar -czpf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" \
            --absolute-names --warning=no-file-changed --directory=/ \
            --exclude="./proc" --exclude="./sys" --exclude="./dev" --exclude="./run" \
            --exclude="./mnt" --exclude="./media" --exclude="./tmp" --exclude="./lost+found" \
            --exclude="./var/lib/docker/overlay2" --exclude="./var/lib/apt/lists" \
            --exclude="./var/cache" --exclude="./var/log" --exclude="./home/runner" \
            --exclude="${{ env.BACKUP_STORE }}" \
            .
          
          BACKUP_SIZE=$(du -h "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | cut -f1)
          echo "âœ… Full system backup created successfully. Size: $BACKUP_SIZE"

      - name: 'â¬†ï¸ Upload Backup as Artifact'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}
          retention-days: 5
          if-no-files-found: error

      - name: 'ðŸ”— Store Backup Link in MEGA'
        if: always()
        run: |
          set -euo pipefail
          echo "ðŸ”— Storing backup artifact link in MEGA as a fallback..."
          sleep 30
          for attempt in {1..5}; do
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')
            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then break; fi
            echo "â³ Waiting for artifact API to update ($attempt/5)..."; sleep 30
          done
          if [[ -z "$ARTIFACT_ID" || "$ARTIFACT_ID" == "null" ]]; then echo "âŒ Could not get artifact ID!"; exit 1; fi
          ARTIFACT_LINK="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
          rclone delete "${MEGA_REMOTE}/latest_backup_link.txt" 2>/dev/null || true
          echo "$ARTIFACT_LINK" | rclone rcat "${MEGA_REMOTE}/latest_backup_link.txt"
          echo "âœ… New backup link stored in MEGA."
          sudo rm -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}"
