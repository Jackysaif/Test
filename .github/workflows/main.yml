name: Rocket-Powered Persistent VPS

on:
  workflow_dispatch:
    inputs:
      skip_restore:
        description: 'Skip restoration from backup (fresh start)'
        required: false
        default: 'false'
        type: boolean
      session_timeout:
        description: 'Session timeout in minutes (max 360)'
        required: false
        default: '360'
        type: string
  workflow_call:
    inputs:
      skip_restore:
        required: false
        default: false
        type: boolean
      session_timeout:
        required: false
        default: '360'
        type: string

env:
  VPS_USER: ${{ secrets.VPS_USER || 'vpsuser' }}
  VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
  VPS_HOSTNAME: github-vps
  BACKUP_RETENTION_DAYS: 7
  GH_TOKEN: ${{ github.token }}
  DEBIAN_FRONTEND: noninteractive

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 360  # Fixed: Using literal value
    
    steps:
      # ===== INITIALIZATION =====
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate inputs
        run: |
          set -euo pipefail
          
          # Validate session timeout
          TIMEOUT="${{ inputs.session_timeout || '360' }}"
          if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || [ "$TIMEOUT" -gt 360 ] || [ "$TIMEOUT" -lt 1 ]; then
            echo "âŒ Invalid session timeout: $TIMEOUT (must be 1-360)"
            exit 1
          fi
          
          # Check required secrets
          if [ -z "${{ secrets.VPS_PASSWORD }}" ]; then
            echo "âŒ VPS_PASSWORD secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.TAILSCALE_AUTHKEY }}" ]; then
            echo "âš ï¸ TAILSCALE_AUTHKEY secret is not set - Tailscale will be skipped"
          fi
          
          echo "âœ… Input validation passed"

      - name: Setup system
        run: |
          set -euo pipefail
          
          # Update package lists with retry
          for i in {1..3}; do
            if sudo apt-get update; then
              break
            fi
            echo "Retry $i/3..."
            sleep 5
          done
          
          # Install required packages
          sudo apt-get install -y \
            curl \
            tmate \
            jq \
            bc \
            software-properties-common \
            openssh-server \
            net-tools \
            htop \
            2>&1 | tee /tmp/apt-install.log
          
          echo "ğŸš€ System tools installed successfully"
          echo "ğŸ“‹ Installed packages: $(grep -c 'Setting up' /tmp/apt-install.log || echo '0')"

      # ===== SECURE SETUP =====
      - name: Configure secure user
        run: |
          set -euo pipefail
          
          USER_NAME="${{ env.VPS_USER }}"
          USER_PASS="${{ env.VPS_PASSWORD }}"
          
          if ! id -u "$USER_NAME" &>/dev/null; then
            # Create user with home directory
            sudo useradd -m -s /bin/bash "$USER_NAME"
            
            # Set password securely
            echo "${USER_NAME}:${USER_PASS}" | sudo chpasswd
            
            # Add to sudo group
            sudo usermod -aG sudo "$USER_NAME"
            
            # Configure SSH directory
            SSH_DIR="/home/${USER_NAME}/.ssh"
            sudo mkdir -p "$SSH_DIR"
            sudo chmod 700 "$SSH_DIR"
            sudo touch "${SSH_DIR}/authorized_keys"
            sudo chmod 600 "${SSH_DIR}/authorized_keys"
            sudo chown -R "${USER_NAME}:${USER_NAME}" "$SSH_DIR"
            
            # Set up sudoers for passwordless sudo (optional)
            echo "${USER_NAME} ALL=(ALL) NOPASSWD:ALL" | sudo tee "/etc/sudoers.d/${USER_NAME}"
            
            echo "âœ… User ${USER_NAME} created with sudo privileges"
          else
            echo "ğŸ” User ${USER_NAME} already exists"
          fi
          
          # Verify user creation
          if id "$USER_NAME" &>/dev/null; then
            echo "âœ… User verification passed"
            id "$USER_NAME"
          else
            echo "âŒ User creation failed"
            exit 1
          fi

      - name: Set hostname and optimize system
        run: |
          set -euo pipefail
          
          # Set hostname
          sudo hostnamectl set-hostname "${{ env.VPS_HOSTNAME }}"
          echo "127.0.1.1 ${{ env.VPS_HOSTNAME }}" | sudo tee -a /etc/hosts
          
          # System optimization
          cat << 'EOF' | sudo tee /etc/sysctl.d/99-github-vps.conf
          # GitHub VPS Optimizations
          vm.swappiness=10
          vm.vfs_cache_pressure=50
          fs.file-max=2097152
          net.core.somaxconn=65535
          net.ipv4.tcp_max_syn_backlog=8192
          net.core.netdev_max_backlog=16384
          EOF
          
          sudo sysctl -p /etc/sysctl.d/99-github-vps.conf
          
          echo "ğŸ·ï¸ Hostname: $(hostname)"
          echo "âš™ï¸ System optimizations applied"

      # ===== BACKUP RESTORATION =====
      - name: Install GitHub CLI
        if: ${{ inputs.skip_restore != 'true' }}
        run: |
          set -euo pipefail
          
          if ! command -v gh &>/dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | \
              sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | \
              sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            
            sudo apt-get update
            sudo apt-get install -y gh
            echo "âœ… GitHub CLI installed"
          else
            echo "âœ… GitHub CLI already installed: $(gh --version | head -1)"
          fi

      - name: Discover latest backup
        if: ${{ inputs.skip_restore != 'true' }}
        id: discover-backup
        run: |
          set -euo pipefail
          mkdir -p restore
          
          # Initialize output variables
          echo "backup_tag=" >> $GITHUB_OUTPUT
          echo "backup_timestamp=" >> $GITHUB_OUTPUT
          echo "backup_found=false" >> $GITHUB_OUTPUT
          
          # Get all releases
          echo "ğŸ” Searching for backups..."
          if ! RELEASES=$(gh release list --limit 20 --json tagName,createdAt --repo "${{ github.repository }}" 2>/dev/null); then
            echo "âš ï¸ No releases found or API error"
            exit 0
          fi
          
          # Find latest backup
          LATEST_BACKUP=""
          LATEST_TIMESTAMP=""
          
          while IFS=$'\t' read -r tag timestamp; do
            if [[ "$tag" == vps-backup-* ]]; then
              LATEST_BACKUP="$tag"
              LATEST_TIMESTAMP="$timestamp"
              break
            fi
          done < <(echo "$RELEASES" | jq -r '.[] | [.tagName, .createdAt] | @tsv')
          
          # Set outputs
          if [[ -n "$LATEST_BACKUP" ]]; then
            echo "backup_tag=$LATEST_BACKUP" >> $GITHUB_OUTPUT
            echo "backup_timestamp=$LATEST_TIMESTAMP" >> $GITHUB_OUTPUT
            echo "backup_found=true" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Found backup: $LATEST_BACKUP"
            echo "ğŸ“… Created: $LATEST_TIMESTAMP"
          else
            echo "âš ï¸ No backup found, starting fresh"
          fi

      - name: Download and validate backup
        if: steps.discover-backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          
          BACKUP_TAG="${{ steps.discover-backup.outputs.backup_tag }}"
          echo "ğŸ“¥ Downloading backup: $BACKUP_TAG"
          
          # Download with retry logic
          for attempt in {1..3}; do
            if gh release download "$BACKUP_TAG" \
              --dir restore \
              --repo "${{ github.repository }}" \
              --clobber; then
              echo "âœ… Download successful"
              break
            else
              echo "âš ï¸ Download attempt $attempt failed"
              sleep 5
            fi
          done
          
          # Validate downloads
          echo "ğŸ” Validating backup integrity..."
          VALID_FILES=0
          INVALID_FILES=0
          
          for file in restore/*.tar.gz; do
            if [[ -f "$file" ]]; then
              if gzip -t "$file" 2>/dev/null; then
                SIZE=$(du -h "$file" | cut -f1)
                COUNT=$(tar -tzf "$file" 2>/dev/null | wc -l || echo "0")
                echo "âœ… $(basename "$file"): Valid ($SIZE, $COUNT files)"
                ((VALID_FILES++))
              else
                echo "âŒ $(basename "$file"): Corrupted, removing"
                rm -f "$file"
                ((INVALID_FILES++))
              fi
            fi
          done
          
          if [[ -f "restore/installed-packages.list" ]]; then
            PACKAGES=$(wc -l < "restore/installed-packages.list")
            echo "âœ… Package list: $PACKAGES packages"
          fi
          
          echo "ğŸ“Š Validation complete: $VALID_FILES valid, $INVALID_FILES invalid"

      - name: Restore system state
        if: steps.discover-backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          
          echo "ğŸ”„ Starting system restoration..."
          RESTORED_ITEMS=0
          
          # Function to safely extract archives
          safe_extract() {
            local archive="$1"
            local target="$2"
            local description="$3"
            
            if [[ -f "$archive" ]]; then
              echo "ğŸ“¦ Restoring $description..."
              if sudo tar -xzf "$archive" -C "$target" 2>/dev/null; then
                echo "âœ… $description restored successfully"
                return 0
              else
                echo "âš ï¸ Failed to restore $description"
                return 1
              fi
            else
              echo "â­ï¸ Skipping $description (not found)"
              return 1
            fi
          }
          
          # Restore user data
          if safe_extract "restore/${{ env.VPS_USER }}-home-full.tar.gz" "/" "user home directory"; then
            ((RESTORED_ITEMS++))
          fi
          
          # Restore system services
          if safe_extract "restore/services-backup.tar.gz" "/" "system services"; then
            ((RESTORED_ITEMS++))
            sudo systemctl daemon-reload
          fi
          
          # Restore configurations
          if safe_extract "restore/system-config.tar.gz" "/" "system configurations"; then
            ((RESTORED_ITEMS++))
          fi
          
          # Restore packages
          if [[ -f "restore/installed-packages.list" ]]; then
            echo "ğŸ“¦ Restoring packages..."
            sudo dpkg --clear-selections
            sudo dpkg --set-selections < restore/installed-packages.list
            sudo apt-get dselect-upgrade -y 2>&1 | tail -20
            ((RESTORED_ITEMS++))
          fi
          
          # Fix permissions
          sudo chown -R "${{ env.VPS_USER }}:${{ env.VPS_USER }}" "/home/${{ env.VPS_USER }}" 2>/dev/null || true
          
          echo "âœ… Restoration completed: $RESTORED_ITEMS components restored"

      # ===== TAILSCALE SETUP =====
      - name: Setup Tailscale with state management
        if: ${{ secrets.TAILSCALE_AUTHKEY != '' }}
        id: tailscale
        run: |
          set -euo pipefail
          
          echo "ğŸŒ Setting up Tailscale..."
          
          # Install Tailscale
          if ! command -v tailscale &>/dev/null; then
            curl -fsSL https://tailscale.com/install.sh | sh
            echo "âœ… Tailscale installed"
          else
            echo "âœ… Tailscale already installed"
          fi
          
          # Start Tailscale daemon
          sudo systemctl start tailscaled
          sleep 3
          
          # Connect to Tailscale
          if [[ -f "/var/lib/tailscale/tailscaled.state" ]]; then
            echo "ğŸ”„ Using existing Tailscale state"
          else
            echo "ğŸ†• Creating new Tailscale connection"
            sudo tailscale up \
              --authkey "${{ secrets.TAILSCALE_AUTHKEY }}" \
              --hostname "${{ env.VPS_HOSTNAME }}" \
              --ssh \
              --accept-routes \
              --accept-dns=false
          fi
          
          # Get connection info
          sleep 5
          TAILSCALE_IP=$(tailscale ip -4 2>/dev/null || echo "pending")
          
          echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
          echo "ğŸŒ Tailscale IP: $TAILSCALE_IP"
          echo "ğŸ”‘ SSH: ssh ${{ env.VPS_USER }}@$TAILSCALE_IP"

      # ===== VPS SESSION =====
      - name: Start persistent session
        id: session
        run: |
          set -euo pipefail
          
          # Get session timeout
          TIMEOUT_MINUTES="${{ inputs.session_timeout || '360' }}"
          TIMEOUT_SECONDS=$((TIMEOUT_MINUTES * 60))
          
          # Get connection info
          TAILSCALE_IP="${{ steps.tailscale.outputs.tailscale_ip || 'Not configured' }}"
          
          # Create session info file
          cat > /tmp/session-info.txt << EOF
          ğŸš€ Rocket VPS Session Started
          ==========================================
          ğŸ‘¤ Username: ${{ env.VPS_USER }}
          ğŸ”‘ Password: [Hidden - Check GitHub Secrets]
          ğŸŒ Tailscale IP: $TAILSCALE_IP
          ğŸ–¥ï¸ Hostname: $(hostname -f)
          â° Timeout: $TIMEOUT_MINUTES minutes
          ğŸ“… Started: $(date '+%Y-%m-%d %H:%M:%S UTC')
          ==========================================
          EOF
          
          cat /tmp/session-info.txt
          
          # Start tmate session
          echo "ğŸ”— Starting tmate session..."
          
          # Create tmate configuration
          cat > ~/.tmate.conf << 'EOF'
          set -g default-terminal "screen-256color"
          set -g history-limit 10000
          set -g mouse on
          EOF
          
          # Start session
          tmate -S /tmp/tmate.sock new-session -d
          tmate -S /tmp/tmate.sock wait tmate-ready
          
          # Get connection details
          TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')
          TMATE_WEB=$(tmate -S /tmp/tmate.sock display -p '#{tmate_web}')
          
          echo "==========================================
          ğŸ”— Connection Methods:
          ==========================================
          SSH: $TMATE_SSH
          Web: $TMATE_WEB
          ==========================================
          "
          
          # Save session info to outputs
          echo "tmate_ssh=$TMATE_SSH" >> $GITHUB_OUTPUT
          echo "tmate_web=$TMATE_WEB" >> $GITHUB_OUTPUT
          echo "session_start=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
          
          # Monitor session
          echo "â³ Session active for $TIMEOUT_MINUTES minutes..."
          echo "ğŸ’¡ Tip: You can cancel the workflow anytime to trigger backup"
          
          # Keep alive with progress indicator
          for ((i=0; i<TIMEOUT_SECONDS; i+=60)); do
            ELAPSED=$((i/60))
            REMAINING=$(((TIMEOUT_SECONDS-i)/60))
            echo "â° Time: ${ELAPSED}/${TIMEOUT_MINUTES} minutes (${REMAINING} remaining)"
            sleep 60
          done
          
          echo "â° Session timeout reached"

      # ===== INTELLIGENT BACKUP =====
      - name: Create smart backup
        if: always()
        id: backup
        run: |
          set -euo pipefail
          
          mkdir -p backup
          echo "ğŸ’¾ Creating intelligent backup..."
          
          # Define exclusion patterns
          EXCLUDE_PATTERNS=(
            --exclude='*.tmp'
            --exclude='*.temp'
            --exclude='*.log'
            --exclude='*.cache'
            --exclude='.cache'
            --exclude='.npm'
            --exclude='.yarn'
            --exclude='.docker'
            --exclude='node_modules'
            --exclude='__pycache__'
            --exclude='.git'
            --exclude='vendor'
            --exclude='venv'
            --exclude='.venv'
          )
          
          # Backup user data with compression
          echo "ğŸ“ Backing up user data..."
          if sudo tar -czf "backup/${{ env.VPS_USER }}-home-full.tar.gz" \
            -C /home \
            "${{ env.VPS_USER }}" \
            "${EXCLUDE_PATTERNS[@]}" \
            --warning=no-file-changed \
            2>/dev/null; then
            echo "âœ… User data backed up"
          else
            echo "âš ï¸ User data backup completed with warnings"
          fi
          
          # Backup system configurations
          echo "âš™ï¸ Backing up system configuration..."
          SYSTEM_DIRS=""
          for dir in /etc/ssh /etc/ssl /etc/systemd/system /etc/cron.d; do
            [[ -d "$dir" ]] && SYSTEM_DIRS="$SYSTEM_DIRS $dir"
          done
          
          if [[ -n "$SYSTEM_DIRS" ]]; then
            sudo tar -czf backup/system-config.tar.gz \
              --ignore-failed-read \
              $SYSTEM_DIRS 2>/dev/null || true
          fi
          
          # Backup services
          echo "ğŸ”§ Backing up services..."
          SERVICE_DIRS=""
          for dir in /etc/apache2 /etc/nginx /etc/mysql /etc/postgresql /var/www; do
            [[ -d "$dir" ]] && SERVICE_DIRS="$SERVICE_DIRS $dir"
          done
          
          if [[ -n "$SERVICE_DIRS" ]]; then
            sudo tar -czf backup/services-backup.tar.gz \
              --ignore-failed-read \
              $SERVICE_DIRS 2>/dev/null || true
          fi
          
          # Backup Tailscale state
          if [[ -f "/var/lib/tailscale/tailscaled.state" ]]; then
            echo "ğŸŒ Backing up Tailscale state..."
            sudo tar -czf backup/tailscale-state.tar.gz \
              -C / \
              var/lib/tailscale/tailscaled.state 2>/dev/null || true
          fi
          
          # Backup package lists
          echo "ğŸ“¦ Backing up package information..."
          dpkg --get-selections > backup/installed-packages.list
          apt-mark showauto > backup/auto-packages.list
          snap list 2>/dev/null > backup/snap-packages.list || true
          
          # Create comprehensive manifest
          echo "ğŸ“ Creating backup manifest..."
          BACKUP_SIZE=$(du -sh backup | cut -f1)
          DISK_USAGE=$(df -h / | awk 'NR==2{print $5}')
          
          cat > backup/manifest.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "3.0",
            "session": {
              "start_time": "${{ steps.session.outputs.session_start || 'N/A' }}",
              "user": "${{ env.VPS_USER }}",
              "hostname": "$(hostname -f)"
            },
            "components": {
              "user_data": {
                "file": "${{ env.VPS_USER }}-home-full.tar.gz",
                "size": "$(du -h backup/${{ env.VPS_USER }}-home-full.tar.gz 2>/dev/null | cut -f1 || echo '0')"
              },
              "system_config": {
                "file": "system-config.tar.gz",
                "size": "$(du -h backup/system-config.tar.gz 2>/dev/null | cut -f1 || echo '0')"
              },
              "services": {
                "file": "services-backup.tar.gz",
                "size": "$(du -h backup/services-backup.tar.gz 2>/dev/null | cut -f1 || echo '0')"
              },
              "packages": {
                "dpkg_count": "$(wc -l < backup/installed-packages.list)",
                "snap_count": "$(wc -l < backup/snap-packages.list 2>/dev/null || echo '0')"
              }
            },
            "system": {
              "tailscale_ip": "${{ steps.tailscale.outputs.tailscale_ip || 'not configured' }}",
              "disk_usage": "$DISK_USAGE",
              "total_backup_size": "$BACKUP_SIZE"
            }
          }
          EOF
          
          # Output backup stats
          echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT
          echo "âœ… Backup created: $BACKUP_SIZE"
          ls -lah backup/

      - name: Upload backup to GitHub Releases
        if: always() && steps.backup.outcome == 'success'
        run: |
          set -euo pipefail
          
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BACKUP_TAG="vps-backup-$TIMESTAMP"
          
          echo "â˜ï¸ Uploading backup: $BACKUP_TAG"
          
          # Create release notes
          RELEASE_NOTES="## ğŸš€ Automated VPS Backup
          
          **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **User:** ${{ env.VPS_USER }}
          **Hostname:** $(hostname -f)
          **Size:** ${{ steps.backup.outputs.backup_size }}
          **Session Duration:** ${{ inputs.session_timeout || '360' }} minutes
          
          ### ğŸ“¦ Components
          - User home directory
          - System configurations  
          - Service configurations
          - Package lists
          - Tailscale state (if configured)
          
          ### ğŸ“Š System Info
          - Disk Usage: $(df -h / | awk 'NR==2{print $5}')
          - Memory: $(free -h | awk 'NR==2{print $3"/"$2}')
          - Uptime: $(uptime -p)
          
          ### ğŸ”„ Restore Command
          \`\`\`bash
          gh workflow run vps.yml -f skip_restore=false
          \`\`\`
          "
          
          # Upload to release
          for attempt in {1..3}; do
            if gh release create "$BACKUP_TAG" \
              backup/* \
              --title "VPS Backup - $TIMESTAMP" \
              --notes "$RELEASE_NOTES" \
              --repo "${{ github.repository }}"; then
              echo "âœ… Backup uploaded successfully"
              break
            else
              echo "âš ï¸ Upload attempt $attempt failed, retrying..."
              sleep 10
            fi
          done

      - name: Cleanup old backups
        if: always()
        run: |
          set -euo pipefail
          
          echo "ğŸ§¹ Cleaning up old backups (retention: ${{ env.BACKUP_RETENTION_DAYS }} days)"
          
          # Calculate cutoff date
          RETENTION_DAYS="${{ env.BACKUP_RETENTION_DAYS }}"
          CUTOFF_DATE=$(date -u -d "$RETENTION_DAYS days ago" +%Y-%m-%dT%H:%M:%SZ)
          CUTOFF_TIMESTAMP=$(date -d "$CUTOFF_DATE" +%s)
          
          # Get all backup releases
          RELEASES=$(gh release list --limit 100 --json tagName,createdAt --repo "${{ github.repository }}")
          
          # Count backups
          TOTAL_BACKUPS=0
          DELETED_BACKUPS=0
          
          # Process each release
          echo "$RELEASES" | jq -c '.[]' | while read -r release; do
            tag=$(echo "$release" | jq -r '.tagName')
            created=$(echo "$release" | jq -r '.createdAt')
            
            if [[ "$tag" == vps-backup-* ]]; then
              ((TOTAL_BACKUPS++))
              
              # Convert creation date to timestamp
              if release_timestamp=$(date -d "$created" +%s 2>/dev/null); then
                if [[ "$release_timestamp" -lt "$CUTOFF_TIMESTAMP" ]]; then
                  echo "ğŸ—‘ï¸ Deleting old backup: $tag (created: $created)"
                  if gh release delete "$tag" --yes --repo "${{ github.repository }}" 2>/dev/null; then
                    ((DELETED_BACKUPS++))
                  fi
                else
                  echo "âœ… Keeping recent backup: $tag (created: $created)"
                fi
              fi
            fi
          done
          
          echo "ğŸ“Š Cleanup complete: Deleted $DELETED_BACKUPS old backups"

      - name: Final status report
        if: always()
        run: |
          set -euo pipefail
          
          echo "
          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘     ğŸš€ ROCKET VPS SESSION COMPLETE       â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          "
          
          # Determine status emoji and message
          case "${{ job.status }}" in
            "cancelled")
              STATUS="ğŸŸ¡ CANCELLED"
              MESSAGE="Session was manually cancelled"
              ;;
            "failure")
              STATUS="ğŸ”´ FAILED"
              MESSAGE="Session encountered errors"
              ;;
            "success")
              STATUS="ğŸŸ¢ SUCCESS"
              MESSAGE="Session completed successfully"
              ;;
            *)
              STATUS="âšª UNKNOWN"
              MESSAGE="Session status unknown"
              ;;
          esac
          
          echo "Status: $STATUS"
          echo "Message: $MESSAGE"
          echo ""
          echo "ğŸ“Š Session Statistics:"
          echo "â”œâ”€ Duration: ${{ inputs.session_timeout || '360' }} minutes"
          echo "â”œâ”€ User: ${{ env.VPS_USER }}"
          echo "â”œâ”€ Hostname: $(hostname -f)"
          echo "â”œâ”€ Backup Created: ${{ steps.backup.outcome == 'success' && 'Yes âœ…' || 'No âŒ' }}"
          echo "â”œâ”€ Backup Size: ${{ steps.backup.outputs.backup_size || 'N/A' }}"
          echo "â”œâ”€ Disk Usage: $(df -h / | awk 'NR==2{print $5}')"
          echo "â””â”€ Memory Usage: $(free -h | awk 'NR==2{print $3"/"$2}')"
          echo ""
          echo "ğŸ”— Connection Info:"
          echo "â”œâ”€ Tailscale IP: ${{ steps.tailscale.outputs.tailscale_ip || 'Not configured' }}"
          echo "â”œâ”€ Tmate SSH: ${{ steps.session.outputs.tmate_ssh || 'Session ended' }}"
          echo "â””â”€ Tmate Web: ${{ steps.session.outputs.tmate_web || 'Session ended' }}"
          echo ""
          echo "ğŸ“ Next Steps:"
          echo "â”œâ”€ To restore this backup: gh workflow run ${{ github.workflow }} -f skip_restore=false"
          echo "â”œâ”€ To start fresh: gh workflow run ${{ github.workflow }} -f skip_restore=true"
          echo "â””â”€ View backups: gh release list --repo ${{ github.repository }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Thank you for using Rocket-Powered VPS! ğŸš€"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
