name: Persistent VPS (Self-Healing Edition)

on:
  schedule:
    # Runs automatically every 6 hours to refresh the session
    - cron: '0 */6 * * *'
  workflow_dispatch:
    # Allows manual triggering from the Actions tab
    inputs:
      force_fresh_install:
        description: 'Force fresh installation (ignore existing backups)'
        required: false
        default: 'false'
        type: boolean
      session_duration:
        description: 'Session duration in minutes (default: 330 = 5.5 hours)'
        required: false
        default: '330'
        type: string

env:
  # Backup configuration
  BACKUP_STORE: /mnt/backups/vps
  BACKUP_NAME: vps-full-backup.tar.gz
  BACKUP_METADATA: vps-metadata.json
  # Cloud storage configuration
  MEGA_REMOTE: mega:vps-backup
  BACKUP_LINK_FILE: latest_backup_link.txt
  METADATA_FILE: backup_metadata.json
  # System configuration
  VPS_HOSTNAME: github-vps
  VPS_USER: vpsuser
  # Session settings
  DEFAULT_SESSION_MINUTES: 330
  HEARTBEAT_INTERVAL: 300

jobs:
  persistent-vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 360  # GitHub Actions maximum
    permissions:
      contents: read
      actions: write

    steps:
      # ================================================================
      # PHASE 1: INITIALIZATION & ENVIRONMENT SETUP
      # ================================================================

      - name: 'üöÄ Initialize VPS Session'
        id: init
        run: |
          set -euo pipefail
          echo "=============================================="
          echo "üöÄ PERSISTENT VPS INITIALIZATION STARTING"
          echo "=============================================="
          echo "Session ID: ${{ github.run_id }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Start Time: $(date -Iseconds)"
          echo "Force Fresh: ${{ inputs.force_fresh_install || 'false' }}"
          
          # Calculate session duration
          DURATION="${{ inputs.session_duration || env.DEFAULT_SESSION_MINUTES }}"
          echo "duration_minutes=$DURATION" >> $GITHUB_OUTPUT
          echo "session_end_time=$(($(date +%s) + DURATION * 60))" >> $GITHUB_OUTPUT
          
          # System info
          echo ""
          echo "üìä System Information:"
          echo "  Runner: $(uname -a)"
          echo "  CPU Cores: $(nproc)"
          echo "  Memory: $(free -h | grep Mem | awk '{print $2}')"
          echo "  Disk Space: $(df -h / | tail -1 | awk '{print $4}' | sed 's/G/ GB/')"
          echo "=============================================="

      - name: 'üì• Checkout Repository'
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 'üõ†Ô∏è Install Core System Tools'
        run: |
          set -euo pipefail
          echo "üîß Installing essential system tools..."
          
          # Update package lists
          echo "üåê Updating package repositories..."
          sudo apt-get update -qq
          
          # Fix any broken packages first
          echo "üîß Fixing any broken packages..."
          sudo apt-get install -f -y || true
          sudo dpkg --configure -a || true
          
          # Remove conflicting packages
          echo "üóëÔ∏è Removing conflicting packages..."
          sudo apt-get remove --purge -y containerd docker docker-engine docker.io containerd runc || true
          sudo apt-get autoremove -y || true
          
          # Install core tools (without Docker first)
          echo "üì¶ Installing system packages..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            curl wget git tar gzip unzip jq \
            openssh-server openssh-client \
            htop nano vim screen tmux \
            net-tools psmisc lsof \
            software-properties-common \
            apt-transport-https \
            ca-certificates \
            gnupg lsb-release \
            build-essential \
            python3 python3-pip \
            rsync \
            mariadb-server mariadb-client
          
          # Install rclone separately
          echo "‚òÅÔ∏è Installing rclone..."
          curl -fsSL https://rclone.org/install.sh | sudo bash
          
          # Install Docker properly
          echo "üê≥ Installing Docker..."
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update -qq
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
          
          # Configure Docker
          echo "üîß Configuring Docker..."
          sudo systemctl enable docker
          sudo usermod -aG docker $USER
          
          echo "‚úÖ Core system tools installed successfully"

      - name: '‚òÅÔ∏è Configure Cloud Storage (Rclone)'
        run: |
          set -euo pipefail
          echo "üîê Configuring Rclone for MEGA storage..."
          
          # Validate required secrets
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "‚ùå ERROR: RCLONE_CONFIG secret is required!" >&2
            echo "Please add your rclone configuration to GitHub Secrets." >&2
            exit 1
          fi
          
          # Setup rclone configuration
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          
          # Test rclone connection
          echo "üß™ Testing MEGA connection..."
          if rclone lsd "${{ env.MEGA_REMOTE }}" >/dev/null 2>&1; then
            echo "‚úÖ MEGA connection successful"
          else
            echo "‚ö†Ô∏è  MEGA connection test failed, but continuing..."
          fi

      # ================================================================
      # PHASE 2: BACKUP DETECTION & RESTORATION
      # ================================================================

      - name: 'üîç Detect Available Backups'
        id: detect_backups
        run: |
          set -euo pipefail
          echo "üîé Searching for existing backups..."
          
          FORCE_FRESH="${{ inputs.force_fresh_install || 'false' }}"
          if [[ "$FORCE_FRESH" == "true" ]]; then
            echo "üîÑ Fresh installation forced by user input"
            echo "has_backup=false" >> $GITHUB_OUTPUT
            echo "backup_source=none" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Priority 1: Check MEGA for backup link
          echo "üéØ Priority 1: Checking MEGA for latest backup link..."
          if rclone ls "${MEGA_REMOTE}/${BACKUP_LINK_FILE}" >/dev/null 2>&1; then
            BACKUP_LINK=$(rclone cat "${MEGA_REMOTE}/${BACKUP_LINK_FILE}" 2>/dev/null || echo "")
            if [[ -n "$BACKUP_LINK" && "$BACKUP_LINK" =~ ^https://api\.github\.com ]]; then
              echo "‚úÖ Found valid backup link in MEGA!"
              echo "has_backup=true" >> $GITHUB_OUTPUT
              echo "backup_source=mega" >> $GITHUB_OUTPUT
              echo "backup_url=$BACKUP_LINK" >> $GITHUB_OUTPUT
              
              # Get metadata if available
              if rclone ls "${MEGA_REMOTE}/${METADATA_FILE}" >/dev/null 2>&1; then
                METADATA=$(rclone cat "${MEGA_REMOTE}/${METADATA_FILE}" 2>/dev/null || echo "{}")
                echo "backup_metadata=$METADATA" >> $GITHUB_OUTPUT
              fi
              exit 0
            fi
          fi
          
          # Priority 2: Search recent GitHub Actions artifacts
          echo "üéØ Priority 2: Searching recent workflow runs..."
          WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows" \
            | jq -r '.workflows[] | select(.name == "Persistent VPS (Self-Healing Edition)") | .id' \
            | head -1)
          
          if [[ -n "$WORKFLOW_ID" && "$WORKFLOW_ID" != "null" ]]; then
            echo "üîç Found workflow ID: $WORKFLOW_ID"
            
            # Get recent successful runs (excluding current run)
            RECENT_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs?status=success&per_page=5" \
              | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id')
            
            for RUN_ID in $RECENT_RUNS; do
              echo "üîé Checking run: $RUN_ID"
              ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/artifacts" \
                | jq -r ".artifacts[] | select(.name == \"${{ env.BACKUP_NAME }}\") | .id" \
                | head -1)
              
              if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
                ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
                echo "‚úÖ Found backup artifact in run $RUN_ID!"
                echo "has_backup=true" >> $GITHUB_OUTPUT
                echo "backup_source=github_artifacts" >> $GITHUB_OUTPUT
                echo "backup_url=$ARTIFACT_URL" >> $GITHUB_OUTPUT
                echo "backup_run_id=$RUN_ID" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          
          echo "‚ÑπÔ∏è  No existing backups found - will perform fresh installation"
          echo "has_backup=false" >> $GITHUB_OUTPUT
          echo "backup_source=none" >> $GITHUB_OUTPUT

      - name: 'üì• Download and Restore System Backup'
        if: steps.detect_backups.outputs.has_backup == 'true'
        run: |
          set -euo pipefail
          echo "üì• Restoring system from backup..."
          echo "Source: ${{ steps.detect_backups.outputs.backup_source }}"
          
          # Check available disk space
          echo "üíæ Checking available disk space..."
          df -h /
          AVAILABLE_GB=$(df / | tail -1 | awk '{print $4}' | sed 's/G//')
          echo "Available space: ${AVAILABLE_GB}G"
          
          # Create restoration workspace with proper permissions
          echo "üìÅ Creating restoration workspace..."
          sudo mkdir -p /mnt/restore
          sudo chown $(whoami):$(whoami) /mnt/restore
          cd /mnt/restore
          
          # Clean any existing files
          rm -f backup_download.zip* backup_*.tar.gz* 2>/dev/null || true
          
          echo "üåê Downloading backup archive..."
          # Download with better error handling and progress
          if ! curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${{ steps.detect_backups.outputs.backup_url }}" \
            -o "backup_download.zip" \
            --fail \
            --max-time 600 \
            --retry 3 \
            --retry-delay 10 \
            --progress-bar; then
            
            echo "‚ùå Download failed. Checking disk space and retrying..."
            df -h /
            
            # Try alternative download location
            cd /tmp
            echo "üîÑ Retrying download in /tmp..."
            curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "${{ steps.detect_backups.outputs.backup_url }}" \
              -o "backup_download.zip" \
              --fail \
              --max-time 300 \
              --retry 2 \
              --progress-bar
            
            mv backup_download.zip /mnt/restore/
            cd /mnt/restore
          fi
          
          # Verify download
          if [[ ! -f "backup_download.zip" ]] || [[ ! -s "backup_download.zip" ]]; then
            echo "‚ùå Download failed or file is empty!"
            ls -la
            exit 1
          fi
          
          DOWNLOAD_SIZE=$(du -h backup_download.zip | cut -f1)
          echo "üì¶ Downloaded: $DOWNLOAD_SIZE"
          
          echo "üìÇ Extracting backup archive..."
          if ! unzip -q backup_download.zip; then
            echo "‚ùå Failed to extract backup!"
            echo "File info:"
            file backup_download.zip
            head -c 100 backup_download.zip | hexdump -C
            exit 1
          fi
          
          # Clean up zip file to save space
          rm -f backup_download.zip
          
          # Verify backup file exists
          if [[ ! -f "${{ env.BACKUP_NAME }}" ]]; then
            echo "‚ùå Expected backup file not found after extraction!"
            echo "Available files:"
            ls -la
            exit 1
          fi
          
          # Validate backup integrity
          echo "üß™ Validating backup integrity..."
          if ! tar -tzf "${{ env.BACKUP_NAME }}" >/dev/null 2>&1; then
            echo "‚ùå Backup file is corrupted!"
            file "${{ env.BACKUP_NAME }}"
            exit 1
          fi
          
          # Display backup information
          BACKUP_SIZE=$(du -h "${{ env.BACKUP_NAME }}" | cut -f1)
          FILE_COUNT=$(tar -tzf "${{ env.BACKUP_NAME }}" | wc -l)
          echo "üìã Backup Details:"
          echo "  Size: $BACKUP_SIZE"
          echo "  Files: $FILE_COUNT"
          
          # Check if we have enough space for extraction (much less needed now)
          BACKUP_SIZE_KB=$(du -k "${{ env.BACKUP_NAME }}" | cut -f1)
          AVAILABLE_KB=$(df /mnt | tail -1 | awk '{print $4}')
          echo "üìä Space check: Backup=${BACKUP_SIZE_KB}KB, Available=${AVAILABLE_KB}KB"
          
          # Restore selective backup (much faster than full OS restore)
          echo "üîÑ Restoring installed software and user data..."
          echo "‚ÑπÔ∏è  This is a selective restore - only your installed software and configs"
          
          # First, restore to temporary location to inspect
          mkdir -p /tmp/restore_preview
          tar -tzf "${{ env.BACKUP_NAME }}" | head -20 > /tmp/restore_preview/contents.txt
          echo "üìã Restoring the following components:"
          cat /tmp/restore_preview/contents.txt
          
          # Perform the selective restoration
          sudo tar -xzpf "${{ env.BACKUP_NAME }}" -C / \
            --numeric-owner \
            --same-permissions \
            --warning=no-timestamp \
            --overwrite \
            2>/dev/null || {
              echo "‚ö†Ô∏è  Some conflicts resolved during restoration (normal)"
            }
          
          # Fix permissions after restoration
          echo "üîß Fixing permissions after restoration..."
          sudo chown -R mysql:mysql /var/lib/mysql 2>/dev/null || true
          sudo chown -R root:docker /var/lib/docker 2>/dev/null || true
          sudo chmod 600 /etc/ssh/ssh_host_* 2>/dev/null || true
          sudo chmod 644 /etc/passwd /etc/group 2>/dev/null || true
          sudo chmod 640 /etc/shadow /etc/gshadow 2>/dev/null || true
          
          # Clean up extracted backup to save space
          rm -f "${{ env.BACKUP_NAME }}"
          rm -rf /tmp/restore_preview
          
          echo "‚úÖ Selective system restoration completed successfully"
          echo "‚ö° Restoration was much faster because we only restored what you installed!"

      # ================================================================
      # PHASE 3: SYSTEM CONFIGURATION & SERVICE SETUP
      # ================================================================

      - name: 'üë§ Configure User Account'
        run: |
          set -euo pipefail
          echo "üë§ Setting up VPS user account..."
          
          # Validate password secret
          if [[ -z "${{ secrets.USER_PASSWORD || '' }}" ]]; then
            echo "‚ùå ERROR: USER_PASSWORD secret is required!" >&2
            echo "Please add a secure password to GitHub Secrets." >&2
            exit 1
          fi
          
          # Create/update user account
          if id "${{ env.VPS_USER }}" >/dev/null 2>&1; then
            echo "üë§ User ${{ env.VPS_USER }} already exists, updating..."
          else
            echo "üë§ Creating new user: ${{ env.VPS_USER }}"
            sudo useradd -m -s /bin/bash "${{ env.VPS_USER }}"
          fi
          
          # Set password and permissions
          echo "${{ env.VPS_USER }}:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
          sudo usermod -aG sudo,docker "${{ env.VPS_USER }}"
          
          # Configure sudo access
          echo "${{ env.VPS_USER }} ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee "/etc/sudoers.d/${{ env.VPS_USER }}" > /dev/null
          
          # Set hostname
          sudo hostnamectl set-hostname "${{ env.VPS_HOSTNAME }}"
          echo "127.0.1.1 ${{ env.VPS_HOSTNAME }}" | sudo tee -a /etc/hosts > /dev/null
          
          echo "‚úÖ User account configured successfully"

      - name: 'üéõÔ∏è Install and Configure Aapanel'
        run: |
          set -euo pipefail
          echo "üéõÔ∏è Setting up Aapanel control panel..."
          
          # Check if Aapanel is already installed (from backup restoration)
          if command -v bt >/dev/null 2>&1 && [[ -d "/www/server" ]]; then
            echo "‚úÖ Aapanel already installed (restored from backup)"
            
            # Restart Aapanel services
            echo "üîÑ Restarting Aapanel services..."
            sudo bt restart || true
            sleep 5
          else
            echo "üì• Installing Aapanel (fresh installation)..."
            
            # Download and install Aapanel
            curl -fsSL -o /tmp/install_aapanel.sh \
              "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"
            chmod +x /tmp/install_aapanel.sh
            
            # Install with timeout and automatic responses
            timeout 900 bash -c "printf 'y\nyes\n' | sudo bash /tmp/install_aapanel.sh" || {
              echo "‚ö†Ô∏è  Aapanel installation timed out, checking if partially installed..."
            }
            
            # Wait for installation to complete
            sleep 10
          fi
          
          # Configure Aapanel if available
          if command -v bt >/dev/null 2>&1; then
            echo "üîß Configuring Aapanel credentials..."
            
            # Set admin username and password
            echo "admin" | sudo bt 6 || echo "Username may already be set"
            echo "${{ secrets.USER_PASSWORD }}" | sudo bt 5 || echo "Password may already be set"
            
            # Start Aapanel
            sudo bt start || true
            sleep 3
            
            echo "‚úÖ Aapanel configured successfully"
          else
            echo "‚ö†Ô∏è  Aapanel installation incomplete, continuing without it"
          fi

      - name: 'üê≥ Configure Docker and Services'
        run: |
          set -euo pipefail
          echo "üê≥ Configuring Docker and system services..."
          
          # Ensure Docker daemon is configured
          sudo mkdir -p /etc/docker
          sudo tee /etc/docker/daemon.json > /dev/null <<EOF
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            },
            "storage-driver": "overlay2"
          }
          EOF
          
          # Configure MariaDB
          echo "üóÑÔ∏è Configuring MariaDB..."
          sudo mysql_install_db --user=mysql --datadir=/var/lib/mysql || true
          
          # Reload systemd and start services
          echo "üîÑ Starting system services..."
          sudo systemctl daemon-reload
          
          # Enable and start services
          for service in docker ssh mariadb; do
            echo "  Starting $service..."
            sudo systemctl enable $service 2>/dev/null || true
            sudo systemctl start $service 2>/dev/null || true
          done
          
          # Wait for services to stabilize
          sleep 5
          
          # Service status check
          echo "üìä Service Status:"
          for service in docker ssh mariadb; do
            if sudo systemctl is-active --quiet $service; then
              echo "  ‚úÖ $service: ACTIVE"
            else
              echo "  ‚ö†Ô∏è  $service: INACTIVE"
            fi
          done

      # ================================================================
      # PHASE 4: REMOTE ACCESS CONFIGURATION
      # ================================================================

      - name: 'üåê Setup Tailscale VPN'
        run: |
          set -euo pipefail
          echo "üåê Setting up Tailscale VPN for secure remote access..."
          
          # Validate Tailscale auth key
          if [[ -z "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
            echo "‚ùå ERROR: TAILSCALE_AUTHKEY secret is required!" >&2
            echo "Please add your Tailscale auth key to GitHub Secrets." >&2
            exit 1
          fi
          
          # Install Tailscale
          echo "üì• Installing Tailscale..."
          curl -fsSL https://tailscale.com/install.sh | sh
          
          # Enable and start Tailscale daemon
          sudo systemctl enable --now tailscaled
          sleep 3
          
          # Connect to Tailscale network
          echo "üîê Connecting to Tailscale network..."
          sudo tailscale up \
            --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" \
            --hostname="${{ env.VPS_HOSTNAME }}" \
            --reset \
            --accept-routes \
            --accept-dns=false
          
          # Wait for connection to establish
          sleep 5
          
          # Get Tailscale IP
          TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null || echo "Not available")
          echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_ENV
          
          if [[ "$TAILSCALE_IP" != "Not available" ]]; then
            echo "‚úÖ Tailscale connected successfully"
            echo "üåê Tailscale IP: $TAILSCALE_IP"
          else
            echo "‚ö†Ô∏è  Tailscale IP not immediately available"
          fi

      - name: 'üîó Setup Emergency SSH Access (tmate)'
        run: |
          set -euo pipefail
          echo "üîó Setting up tmate for emergency SSH access..."
          
          # Install tmate if not already installed
          if ! command -v tmate >/dev/null 2>&1; then
            echo "üì• Installing tmate..."
            sudo apt-get update -qq
            sudo apt-get install -y tmate
          fi
          
          # Start tmate session
          echo "üöÄ Starting tmate session..."
          tmate -S /tmp/tmate.sock new-session -d 'bash'
          
          # Wait for tmate to be ready
          echo "‚è≥ Waiting for tmate session to initialize..."
          timeout 30 bash -c 'while ! tmate -S /tmp/tmate.sock has-session 2>/dev/null; do sleep 1; done' || {
            echo "‚ö†Ô∏è  tmate session startup timeout"
            exit 0
          }
          
          # Wait for remote connection info
          timeout 30 tmate -S /tmp/tmate.sock wait tmate-ready || {
            echo "‚ö†Ô∏è  tmate remote connection timeout"
            exit 0
          }
          
          # Get connection information
          TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo "Not available")
          TMATE_WEB=$(tmate -S /tmp/tmate.sock display -p '#{tmate_web}' 2>/dev/null || echo "Not available")
          
          echo "tmate_ssh=$TMATE_SSH" >> $GITHUB_ENV
          echo "tmate_web=$TMATE_WEB" >> $GITHUB_ENV
          
          echo "‚úÖ tmate emergency access configured"

      # ================================================================
      # PHASE 5: VPS SESSION MANAGEMENT
      # ================================================================

      - name: 'üéâ VPS Ready - Display Connection Information'
        run: |
          set -euo pipefail
          echo ""
          echo "=================================================="
          echo "üéâ          VPS IS READY FOR USE!              üéâ"
          echo "=================================================="
          echo ""
          echo "üìä System Information:"
          echo "  Hostname: ${{ env.VPS_HOSTNAME }}"
          echo "  Username: ${{ env.VPS_USER }}"
          echo "  Session Duration: ${{ steps.init.outputs.duration_minutes }} minutes"
          echo "  Backup Restored: ${{ steps.detect_backups.outputs.has_backup }}"
          if [[ "${{ steps.detect_backups.outputs.has_backup }}" == "true" ]]; then
            echo "  Backup Source: ${{ steps.detect_backups.outputs.backup_source }}"
          fi
          echo ""
          echo "üåê Remote Access Options:"
          if [[ -n "${tailscale_ip:-}" && "${tailscale_ip}" != "Not available" ]]; then
            echo "  üîê Tailscale VPN: ssh ${{ env.VPS_USER }}@${tailscale_ip}"
            echo "  üîê Tailscale IP: ${tailscale_ip}"
          else
            echo "  ‚ö†Ô∏è  Tailscale: Connection pending..."
          fi
          if [[ -n "${tmate_ssh:-}" && "${tmate_ssh}" != "Not available" ]]; then
            echo "  üÜò Emergency SSH: ${tmate_ssh}"
          fi
          if [[ -n "${tmate_web:-}" && "${tmate_web}" != "Not available" ]]; then
            echo "  üåê Web Terminal: ${tmate_web}"
          fi
          echo ""
          if command -v bt >/dev/null 2>&1; then
            echo "üéõÔ∏è Aapanel Control Panel:"
            sudo bt default 2>/dev/null || echo "  ‚ÑπÔ∏è  Run 'sudo bt default' to get panel URL"
            echo ""
          fi
          echo "üí° Useful Commands:"
          echo "  ‚Ä¢ Stop VPS early: touch /tmp/stop"
          echo "  ‚Ä¢ Check services: systemctl status docker ssh mariadb"
          echo "  ‚Ä¢ Aapanel commands: sudo bt"
          echo "  ‚Ä¢ View logs: journalctl -f"
          echo ""
          echo "=================================================="

      - name: '‚è≥ Maintain VPS Session'
        id: maintain_session
        run: |
          set -euo pipefail
          echo "üñ•Ô∏è  Starting VPS session maintenance..."
          
          SESSION_DURATION=${{ steps.init.outputs.duration_minutes }}
          END_TIME=${{ steps.init.outputs.session_end_time }}
          HEARTBEAT_INTERVAL=${{ env.HEARTBEAT_INTERVAL }}
          
          echo "üìÖ Session Details:"
          echo "  Duration: ${SESSION_DURATION} minutes"
          echo "  Started: $(date -Iseconds)"
          echo "  Will end: $(date -Iseconds -d "@${END_TIME}")"
          echo "  Heartbeat: Every ${HEARTBEAT_INTERVAL} seconds"
          echo ""
          echo "üí° To stop early: touch /tmp/stop"
          echo ""
          
          # Main session loop
          last_heartbeat=0
          while [[ $(date +%s) -lt $END_TIME ]]; do
            current_time=$(date +%s)
            remaining_minutes=$(( (END_TIME - current_time) / 60 ))
            
            # Check for early termination
            if [[ -f "/tmp/stop" ]]; then
              echo "‚úÖ Early termination requested by user"
              rm -f "/tmp/stop"
              echo "stop_reason=user_requested" >> $GITHUB_OUTPUT
              break
            fi
            
            # Periodic heartbeat and status
            if (( current_time - last_heartbeat >= HEARTBEAT_INTERVAL )); then
              echo "üíì Heartbeat: $remaining_minutes minutes remaining - $(date -Iseconds)"
              
              # System health check
              if (( remaining_minutes % 30 == 0 )); then
                echo "üè• Health Check:"
                echo "  Load: $(uptime | awk -F'load average:' '{print $2}')"
                echo "  Memory: $(free -h | grep Mem | awk '{print $3"/"$2}')"
                echo "  Disk: $(df -h / | tail -1 | awk '{print $5}')"
                
                # Service status
                for service in docker ssh mariadb tailscaled; do
                  if systemctl is-active --quiet $service 2>/dev/null; then
                    echo "  ‚úÖ $service: Active"
                  else
                    echo "  ‚ö†Ô∏è  $service: Inactive"
                  fi
                done
              fi
              
              last_heartbeat=$current_time
            fi
            
            sleep 60
          done
          
          if [[ ! -f "/tmp/stop" ]]; then
            echo "‚è∞ Session time limit reached"
            echo "stop_reason=time_limit" >> $GITHUB_OUTPUT
          fi
          
          echo ""
          echo "üìä Session Summary:"
          echo "  Actual runtime: $(( ($(date +%s) - $(date +%s -d '${{ steps.init.outputs.session_start_time || '1 hour ago' }}')) / 60 )) minutes"
          echo "  Stop reason: $(cat $GITHUB_OUTPUT | grep stop_reason | cut -d'=' -f2 || echo 'time_limit')"
          echo "üîÑ Preparing for backup and shutdown..."

      # ================================================================
      # PHASE 6: BACKUP CREATION & STORAGE
      # ================================================================

      - name: 'üíæ Create System Backup'
        if: always()
        id: create_backup
        run: |
          set -euo pipefail
          echo "üíæ Creating selective backup of installed software and user data..."
          
          # Create backup directory with proper permissions
          sudo mkdir -p "${{ env.BACKUP_STORE }}"
          sudo chown $(whoami):$(whoami) "${{ env.BACKUP_STORE }}"
          
          # Stop services cleanly for consistent backup
          echo "üõë Stopping services for consistent backup..."
          if command -v bt >/dev/null 2>&1; then
            sudo bt stop || echo "Aapanel stop failed"
          fi
          sudo systemctl stop mariadb docker tailscaled || echo "Service stop warnings ignored"
          sync
          sleep 3
          
          echo "üìù Creating backup manifest..."
          # Create list of what we're backing up (with proper permissions)
          cat > "${{ env.BACKUP_STORE }}/backup_manifest.txt" <<EOF
          # VPS Backup Manifest - $(date)
          # This backup contains only installed software and user data
          
          DIRECTORIES INCLUDED:
          - /home/* (all user data)
          - /etc/* (system configurations)  
          - /var/lib/mysql/* (MariaDB databases)
          - /var/lib/docker/* (Docker containers and volumes)
          - /opt/* (optional software installations)
          - /usr/local/* (locally installed software)
          - /www/* (Aapanel web files)
          - /root/.* (root user configs)
          - Custom configs and installations
          
          EXCLUDED:
          - Base Ubuntu system files
          - Temporary files
          - Cache files
          - Log files (except important ones)
          - Virtual filesystems
          EOF
          
          echo "üì¶ Creating selective backup archive..."
          
          # Create list of paths that actually exist
          BACKUP_PATHS=""
          
          # Check each path and add if it exists
          for path in /home /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/sudoers.d /etc/hostname /etc/hosts /etc/ssh/sshd_config /root/.ssh /root/.config /root/.bashrc /root/.profile; do
            if [[ -e "$path" ]]; then
              BACKUP_PATHS="$BACKUP_PATHS $path"
            fi
          done
          
          # Check for service-specific directories
          [[ -d /etc/docker ]] && BACKUP_PATHS="$BACKUP_PATHS /etc/docker"
          [[ -d /etc/mysql ]] && BACKUP_PATHS="$BACKUP_PATHS /etc/mysql"
          [[ -d /etc/apache2 ]] && BACKUP_PATHS="$BACKUP_PATHS /etc/apache2"
          [[ -d /etc/nginx ]] && BACKUP_PATHS="$BACKUP_PATHS /etc/nginx"
          [[ -d /etc/php ]] && BACKUP_PATHS="$BACKUP_PATHS /etc/php"
          [[ -d /var/lib/mysql ]] && BACKUP_PATHS="$BACKUP_PATHS /var/lib/mysql"
          [[ -d /var/lib/docker ]] && BACKUP_PATHS="$BACKUP_PATHS /var/lib/docker"
          [[ -d /var/lib/tailscale ]] && BACKUP_PATHS="$BACKUP_PATHS /var/lib/tailscale"
          [[ -d /opt ]] && BACKUP_PATHS="$BACKUP_PATHS /opt"
          [[ -d /usr/local ]] && BACKUP_PATHS="$BACKUP_PATHS /usr/local"
          [[ -d /www ]] && BACKUP_PATHS="$BACKUP_PATHS /www"
          [[ -d /server ]] && BACKUP_PATHS="$BACKUP_PATHS /server"
          
          echo "üìã Backing up the following paths:"
          echo "$BACKUP_PATHS" | tr ' ' '\n' | grep -v '^

      - name: '‚¨ÜÔ∏è Upload Backup to GitHub Artifacts'
        if: always() && steps.create_backup.outputs.backup_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: |
            ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}
            ${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}
          retention-days: 7
          compression-level: 0  # Already compressed
          if-no-files-found: error

      - name: '‚òÅÔ∏è Store Backup Link in MEGA'
        if: always() && steps.create_backup.outputs.backup_created == 'true'
        run: |
          set -euo pipefail
          echo "‚òÅÔ∏è Storing backup reference in MEGA cloud storage..."
          
          # Wait for GitHub artifact to be processed
          echo "‚è≥ Waiting for artifact processing..."
          sleep 30
          
          # Retry loop to get artifact ID
          for attempt in {1..10}; do
            echo "üîç Attempt $attempt/10: Getting artifact ID..."
            
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r ".artifacts[] | select(.name == \"${{ env.BACKUP_NAME }}\") | .id" \
              | head -1)
            
            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
              echo "‚úÖ Found artifact ID: $ARTIFACT_ID"
              break
            fi
            
            echo "‚è≥ Artifact not ready yet, waiting..."
            sleep 20
          done
          
          if [[ -z "$ARTIFACT_ID" || "$ARTIFACT_ID" == "null" ]]; then
            echo "‚ùå Could not retrieve artifact ID after 10 attempts!"
            echo "This may affect restoration in future runs."
            exit 0  # Don't fail the entire workflow
          fi
          
          # Create artifact download URL
          ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
          
          echo "üîó Storing backup link in MEGA..."
          # Remove old backup link
          rclone delete "${MEGA_REMOTE}/${BACKUP_LINK_FILE}" 2>/dev/null || true
          
          # Store new backup link
          echo "$ARTIFACT_URL" | rclone rcat "${MEGA_REMOTE}/${BACKUP_LINK_FILE}"
          
          # Store metadata
          if [[ -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}" ]]; then
            rclone copyto "${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}" \
              "${MEGA_REMOTE}/${METADATA_FILE}"
          fi
          
          echo "‚úÖ Backup reference stored in MEGA successfully"
          echo "üìã Stored Information:"
          echo "  Artifact ID: $ARTIFACT_ID"
          echo "  Download URL: $ARTIFACT_URL"
          echo "  MEGA Path: ${MEGA_REMOTE}/${BACKUP_LINK_FILE}"

      - name: 'üßπ Cleanup Local Storage'
        if: always()
        run: |
          set -euo pipefail
          echo "üßπ Cleaning up local storage..."
          
          # Remove backup files to free disk space
          sudo rm -rf "${{ env.BACKUP_STORE }}" || true
          sudo rm -rf /mnt/restore || true
          sudo rm -rf /tmp/tmate.sock* || true
          
          # Clean package cache
          sudo apt-get clean || true
          sudo apt-get autoremove -y || true
          
          # Clean Docker if it's running
          if command -v docker >/dev/null 2>&1; then
            docker system prune -f || true
          fi
          
          echo "‚úÖ Local cleanup completed"

      # ================================================================
      # PHASE 7: SESSION COMPLETION & REPORTING
      # ================================================================

      - name: 'üìä Generate Session Report'
        if: always()
        id: Session_report
        run: |
          set -euo pipefail
          echo "üìä Generating comprehensive session report..."
          
          # Calculate session metrics
          SESSION_START="${{ steps.init.outputs.session_start_time || '1970-01-01T00:00:00Z' }}"
          SESSION_END=$(date -Iseconds)
          
          if [[ "$SESSION_START" != "1970-01-01T00:00:00Z" ]]; then
            ACTUAL_DURATION=$(( ($(date +%s) - $(date +%s -d "$SESSION_START")) / 60 ))
          else
            ACTUAL_DURATION="unknown"
          fi
          
          # System information
          FINAL_LOAD=$(uptime | awk -F'load average:' '{print $2}' | xargs)
          MEMORY_USAGE=$(free -h | grep Mem | awk '{print $3"/"$2}')
          DISK_USAGE=$(df -h / | tail -1 | awk '{print $3"/"$2" ("$5")"}')
          
          # Service status
          SERVICES_STATUS=""
          for service in docker ssh mariadb tailscaled; do
            if systemctl is-active --quiet $service 2>/dev/null; then
              SERVICES_STATUS="${SERVICES_STATUS}‚úÖ $service "
            else
              SERVICES_STATUS="${SERVICES_STATUS}‚ùå $service "
            fi
          done
          
          # Generate report
          cat <<EOF > /tmp/session_report.txt
          ==========================================
          üéØ PERSISTENT VPS SESSION REPORT
          ==========================================
          
          üìÖ Session Information:
            Session ID: ${{ github.run_id }}
            Repository: ${{ github.repository }}
            Workflow: ${{ github.workflow }}
            Trigger: ${{ github.event_name }}
            Started: $SESSION_START
            Ended: $SESSION_END
            Planned Duration: ${{ steps.init.outputs.duration_minutes || 'unknown' }} minutes
            Actual Duration: $ACTUAL_DURATION minutes
            Stop Reason: ${{ steps.maintain_session.outputs.stop_reason || 'workflow_completion' }}
          
          üîÑ Backup & Restoration:
            Had Previous Backup: ${{ steps.detect_backups.outputs.has_backup || 'false' }}
            Backup Source: ${{ steps.detect_backups.outputs.backup_source || 'none' }}
            New Backup Created: ${{ steps.create_backup.outputs.backup_created || 'false' }}
            Backup Size: ${{ steps.create_backup.outputs.backup_size || 'N/A' }}
            Files Backed Up: ${{ steps.create_backup.outputs.file_count || 'N/A' }}
          
          üñ•Ô∏è System Configuration:
            Hostname: ${{ env.VPS_HOSTNAME }}
            Username: ${{ env.VPS_USER }}
            OS: Ubuntu 22.04 LTS
            Kernel: $(uname -r)
            Architecture: $(uname -m)
          
          üåê Network Access:
            Tailscale IP: ${tailscale_ip:-'Not configured'}
            Emergency SSH: ${tmate_ssh:-'Not available'}
            Web Terminal: ${tmate_web:-'Not available'}
          
          üìä Final System Status:
            Load Average: $FINAL_LOAD
            Memory Usage: $MEMORY_USAGE
            Disk Usage: $DISK_USAGE
            Services: $SERVICES_STATUS
          
          üõ†Ô∏è Installed Components:
            ‚úÖ Core System Tools (curl, git, tar, etc.)
            $(command -v docker >/dev/null && echo "‚úÖ Docker Engine" || echo "‚ùå Docker Engine")
            $(systemctl is-enabled mariadb >/dev/null 2>&1 && echo "‚úÖ MariaDB Database" || echo "‚ùå MariaDB Database")
            $(command -v bt >/dev/null && echo "‚úÖ Aapanel Control Panel" || echo "‚ùå Aapanel Control Panel")
            $(command -v tailscale >/dev/null && echo "‚úÖ Tailscale VPN" || echo "‚ùå Tailscale VPN")
            $(command -v tmate >/dev/null && echo "‚úÖ tmate Remote Access" || echo "‚ùå tmate Remote Access")
            $(command -v rclone >/dev/null && echo "‚úÖ Rclone Cloud Storage" || echo "‚ùå Rclone Cloud Storage")
          
          üí° Next Session:
            - Will automatically start in ~6 hours (if scheduled)
            - Can be manually triggered from Actions tab
            - Will restore from backup created in this session
            - Use 'force_fresh_install' to start clean if needed
          
          ==========================================
          EOF
          
          echo "report_generated=true" >> $GITHUB_OUTPUT

      - name: 'üìã Display Final Session Summary'
        if: always()
        run: |
          set -euo pipefail
          
          if [[ -f "/tmp/session_report.txt" ]]; then
            echo ""
            cat /tmp/session_report.txt
            echo ""
          fi
          
          echo "=============================================="
          echo "üèÅ SESSION COMPLETED SUCCESSFULLY"
          echo "=============================================="
          echo ""
          echo "‚ú® Key Achievements:"
          echo "  ‚Ä¢ VPS environment maintained for ${{ steps.init.outputs.duration_minutes || 'planned' }} minutes"
          echo "  ‚Ä¢ System state preserved through comprehensive backup"
          echo "  ‚Ä¢ Remote access configured (Tailscale + tmate)"
          echo "  ‚Ä¢ All critical services installed and running"
          echo "  ‚Ä¢ Automatic restoration capability established"
          echo ""
          echo "üîÑ Continuous Operation:"
          echo "  ‚Ä¢ Next session will auto-start in ~6 hours"
          echo "  ‚Ä¢ Previous state will be automatically restored"
          echo "  ‚Ä¢ Manual triggers available via Actions tab"
          echo ""
          echo "üìû Support & Troubleshooting:"
          echo "  ‚Ä¢ Check workflow logs for detailed information"
          echo "  ‚Ä¢ Use 'force_fresh_install' if restoration fails"
          echo "  ‚Ä¢ Ensure all required secrets are configured"
          echo ""
          echo "üéØ Status: ${{ job.status || 'COMPLETED' }}"
          echo "üïê End Time: $(date -Iseconds)"
          echo "=============================================="

      # ================================================================
      # PHASE 8: ERROR HANDLING & NOTIFICATIONS
      # ================================================================

      - name: 'üö® Handle Workflow Failures'
        if: failure()
        run: |
          set -euo pipefail
          echo "üö® WORKFLOW FAILURE DETECTED"
          echo "=============================================="
          echo ""
          echo "‚ùå The VPS session encountered an error and could not complete successfully."
          echo ""
          echo "üîç Common Issues & Solutions:"
          echo ""
          echo "1. Missing Secrets:"
          echo "   ‚Ä¢ RCLONE_CONFIG: Required for backup storage"
          echo "   ‚Ä¢ USER_PASSWORD: Required for VPS user account"
          echo "   ‚Ä¢ TAILSCALE_AUTHKEY: Required for VPN access"
          echo ""
          echo "2. Backup/Restoration Issues:"
          echo "   ‚Ä¢ Try running with 'force_fresh_install: true'"
          echo "   ‚Ä¢ Check MEGA storage connectivity"
          echo "   ‚Ä¢ Verify GitHub artifact retention"
          echo ""
          echo "3. Service Startup Problems:"
          echo "   ‚Ä¢ Some services may fail on first install"
          echo "   ‚Ä¢ Check individual service logs"
          echo "   ‚Ä¢ Services often work after restoration"
          echo ""
          echo "4. Resource Limitations:"
          echo "   ‚Ä¢ GitHub runners have limited resources"
          echo "   ‚Ä¢ Large backups may cause timeouts"
          echo "   ‚Ä¢ Consider reducing backup scope"
          echo ""
          echo "üí° Next Steps:"
          echo "   ‚Ä¢ Review the workflow logs above"
          echo "   ‚Ä¢ Check your GitHub Secrets configuration"
          echo "   ‚Ä¢ Try manual trigger with fresh install"
          echo "   ‚Ä¢ Wait for automatic retry in 6 hours"
          echo ""
          echo "=============================================="
          
          # Try to create a minimal backup even on failure
          if [[ -d "/home" || -d "/etc" ]]; then
            echo "üÜò Attempting emergency backup of critical data..."
            sudo mkdir -p "${{ env.BACKUP_STORE }}" || true
            sudo tar -czf "${{ env.BACKUP_STORE }}/emergency-backup.tar.gz" \
              /home /etc /var/lib/mysql /var/lib/docker 2>/dev/null || true
            echo "Emergency backup attempt completed (may be partial)"
          fi

      - name: '‚úÖ Workflow Success Confirmation'
        if: success()
        run: |
          echo "‚úÖ PERSISTENT VPS WORKFLOW COMPLETED SUCCESSFULLY!"
          echo ""
          echo "üéâ All phases completed without errors:"
          echo "  ‚úÖ System initialization and tool installation"
          echo "  ‚úÖ Backup detection and restoration (if available)"
          echo "  ‚úÖ User account and service configuration"
          echo "  ‚úÖ Remote access setup (Tailscale + tmate)"
          echo "  ‚úÖ VPS session maintenance"
          echo "  ‚úÖ Comprehensive backup creation"
          echo "  ‚úÖ Cloud storage integration"
          echo ""
          echo "üîÑ The persistent VPS system is now fully operational!"
          echo "üìÖ Next automatic session: $(date -d '+6 hours' -Iseconds)"
          
          # Create backup with only existing paths
          if [[ -n "$BACKUP_PATHS" ]]; then
            sudo tar -czpf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" \
              --absolute-names \
              --numeric-owner \
              --same-permissions \
              --warning=no-timestamp \
              --exclude-caches \
              --exclude='*.log' \
              --exclude='*.tmp' \
              --exclude='/var/log/*' \
              --exclude='/var/cache/*' \
              --exclude='/var/tmp/*' \
              --exclude='/tmp/*' \
              --exclude='/home/*/.cache/*' \
              --exclude='/root/.cache/*' \
              $BACKUP_PATHS \
              2>/dev/null || {
              echo "‚ö†Ô∏è  Some paths not accessible (normal)"
            }
          else
            echo "‚ö†Ô∏è  No backup paths found, creating minimal backup..."
            # Create a minimal backup with just user configs
            sudo tar -czpf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" \
              --absolute-names \
              /etc/passwd /etc/shadow /etc/group /etc/hostname /etc/hosts \
              2>/dev/null || true
          fi
          
          # Add backup manifest to archive
          cd "${{ env.BACKUP_STORE }}"
          tar -czpf temp_manifest.tar.gz backup_manifest.txt
          sudo tar --concatenate -f "${{ env.BACKUP_NAME }}" temp_manifest.tar.gz 2>/dev/null || {
            echo "‚ÑπÔ∏è  Manifest added separately"
          }
          rm -f temp_manifest.tar.gz backup_manifest.txt
          
          # Verify backup creation
          if [[ -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" ]]; then
            BACKUP_SIZE=$(du -h "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | cut -f1)
            FILE_COUNT=$(tar -tzf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | wc -l)
            
            echo "‚úÖ Selective backup created successfully!"
            echo "üìä Backup Details:"
            echo "  Size: $BACKUP_SIZE (much smaller than full OS backup!)"
            echo "  Files: $FILE_COUNT"
            echo "  Location: ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}"
            echo "  Type: Selective (installed software + user data only)"
            
            # Show what's actually in the backup
            echo ""
            echo "üìã Backup Contents Preview:"
            tar -tzf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | head -20 | sed 's/^/  /'
            
            echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT
            echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
            echo "backup_created=true" >> $GITHUB_OUTPUT
            
            # Create improved backup metadata
            cat > "${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}" <<EOF
          {
            "created_at": "$(date -Iseconds)",
            "backup_type": "selective",
            "run_id": "${{ github.run_id }}",
            "workflow": "${{ github.workflow }}",
            "repository": "${{ github.repository }}",
            "backup_size": "$BACKUP_SIZE",
            "file_count": $FILE_COUNT,
            "system_info": {
              "hostname": "${{ env.VPS_HOSTNAME }}",
              "kernel": "$(uname -r)",
              "ubuntu_version": "$(lsb_release -d | cut -f2)"
            },
            "services_backed_up": {
              "aapanel": $(command -v bt >/dev/null && echo "true" || echo "false"),
              "docker": $(test -d /var/lib/docker && echo "true" || echo "false"),
              "mariadb": $(test -d /var/lib/mysql && echo "true" || echo "false"),
              "tailscale": $(test -d /var/lib/tailscale && echo "true" || echo "false"),
              "user_configs": true,
              "system_configs": true
            },
            "backup_strategy": "selective_installation_only",
            "estimated_restoration_time": "2-5 minutes"
          }
          EOF
          else
            echo "‚ùå Backup creation failed!"
            echo "backup_created=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: '‚¨ÜÔ∏è Upload Backup to GitHub Artifacts'
        if: always() && steps.create_backup.outputs.backup_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: |
            ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}
            ${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}
          retention-days: 7
          compression-level: 0  # Already compressed
          if-no-files-found: error

      - name: '‚òÅÔ∏è Store Backup Link in MEGA'
        if: always() && steps.create_backup.outputs.backup_created == 'true'
        run: |
          set -euo pipefail
          echo "‚òÅÔ∏è Storing backup reference in MEGA cloud storage..."
          
          # Wait for GitHub artifact to be processed
          echo "‚è≥ Waiting for artifact processing..."
          sleep 30
          
          # Retry loop to get artifact ID
          for attempt in {1..10}; do
            echo "üîç Attempt $attempt/10: Getting artifact ID..."
            
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r ".artifacts[] | select(.name == \"${{ env.BACKUP_NAME }}\") | .id" \
              | head -1)
            
            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
              echo "‚úÖ Found artifact ID: $ARTIFACT_ID"
              break
            fi
            
            echo "‚è≥ Artifact not ready yet, waiting..."
            sleep 20
          done
          
          if [[ -z "$ARTIFACT_ID" || "$ARTIFACT_ID" == "null" ]]; then
            echo "‚ùå Could not retrieve artifact ID after 10 attempts!"
            echo "This may affect restoration in future runs."
            exit 0  # Don't fail the entire workflow
          fi
          
          # Create artifact download URL
          ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
          
          echo "üîó Storing backup link in MEGA..."
          # Remove old backup link
          rclone delete "${MEGA_REMOTE}/${BACKUP_LINK_FILE}" 2>/dev/null || true
          
          # Store new backup link
          echo "$ARTIFACT_URL" | rclone rcat "${MEGA_REMOTE}/${BACKUP_LINK_FILE}"
          
          # Store metadata
          if [[ -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}" ]]; then
            rclone copyto "${{ env.BACKUP_STORE }}/${{ env.BACKUP_METADATA }}" \
              "${MEGA_REMOTE}/${METADATA_FILE}"
          fi
          
          echo "‚úÖ Backup reference stored in MEGA successfully"
          echo "üìã Stored Information:"
          echo "  Artifact ID: $ARTIFACT_ID"
          echo "  Download URL: $ARTIFACT_URL"
          echo "  MEGA Path: ${MEGA_REMOTE}/${BACKUP_LINK_FILE}"

      - name: 'üßπ Cleanup Local Storage'
        if: always()
        run: |
          set -euo pipefail
          echo "üßπ Cleaning up local storage..."
          
          # Remove backup files to free disk space
          sudo rm -rf "${{ env.BACKUP_STORE }}" || true
          sudo rm -rf /mnt/restore || true
          sudo rm -rf /tmp/tmate.sock* || true
          
          # Clean package cache
          sudo apt-get clean || true
          sudo apt-get autoremove -y || true
          
          # Clean Docker if it's running
          if command -v docker >/dev/null 2>&1; then
            docker system prune -f || true
          fi
          
          echo "‚úÖ Local cleanup completed"

      # ================================================================
      # PHASE 7: SESSION COMPLETION & REPORTING
      # ================================================================

      - name: 'üìä Generate Session Report'
        if: always()
        id: session_report
        run: |
          set -euo pipefail
          echo "üìä Generating comprehensive session report..."
          
          # Calculate session metrics
          SESSION_START="${{ steps.init.outputs.session_start_time || '1970-01-01T00:00:00Z' }}"
          SESSION_END=$(date -Iseconds)
          
          if [[ "$SESSION_START" != "1970-01-01T00:00:00Z" ]]; then
            ACTUAL_DURATION=$(( ($(date +%s) - $(date +%s -d "$SESSION_START")) / 60 ))
          else
            ACTUAL_DURATION="unknown"
          fi
          
          # System information
          FINAL_LOAD=$(uptime | awk -F'load average:' '{print $2}' | xargs)
          MEMORY_USAGE=$(free -h | grep Mem | awk '{print $3"/"$2}')
          DISK_USAGE=$(df -h / | tail -1 | awk '{print $3"/"$2" ("$5")"}')
          
          # Service status
          SERVICES_STATUS=""
          for service in docker ssh mariadb tailscaled; do
            if systemctl is-active --quiet $service 2>/dev/null; then
              SERVICES_STATUS="${SERVICES_STATUS}‚úÖ $service "
            else
              SERVICES_STATUS="${SERVICES_STATUS}‚ùå $service "
            fi
          done
          
          # Generate report
          cat <<EOF > /tmp/session_report.txt
          ==========================================
          üéØ PERSISTENT VPS SESSION REPORT
          ==========================================
          
          üìÖ Session Information:
            Session ID: ${{ github.run_id }}
            Repository: ${{ github.repository }}
            Workflow: ${{ github.workflow }}
            Trigger: ${{ github.event_name }}
            Started: $SESSION_START
            Ended: $SESSION_END
            Planned Duration: ${{ steps.init.outputs.duration_minutes || 'unknown' }} minutes
            Actual Duration: $ACTUAL_DURATION minutes
            Stop Reason: ${{ steps.maintain_session.outputs.stop_reason || 'workflow_completion' }}
          
          üîÑ Backup & Restoration:
            Had Previous Backup: ${{ steps.detect_backups.outputs.has_backup || 'false' }}
            Backup Source: ${{ steps.detect_backups.outputs.backup_source || 'none' }}
            New Backup Created: ${{ steps.create_backup.outputs.backup_created || 'false' }}
            Backup Size: ${{ steps.create_backup.outputs.backup_size || 'N/A' }}
            Files Backed Up: ${{ steps.create_backup.outputs.file_count || 'N/A' }}
          
          üñ•Ô∏è System Configuration:
            Hostname: ${{ env.VPS_HOSTNAME }}
            Username: ${{ env.VPS_USER }}
            OS: Ubuntu 22.04 LTS
            Kernel: $(uname -r)
            Architecture: $(uname -m)
          
          üåê Network Access:
            Tailscale IP: ${tailscale_ip:-'Not configured'}
            Emergency SSH: ${tmate_ssh:-'Not available'}
            Web Terminal: ${tmate_web:-'Not available'}
          
          üìä Final System Status:
            Load Average: $FINAL_LOAD
            Memory Usage: $MEMORY_USAGE
            Disk Usage: $DISK_USAGE
            Services: $SERVICES_STATUS
          
          üõ†Ô∏è Installed Components:
            ‚úÖ Core System Tools (curl, git, tar, etc.)
            $(command -v docker >/dev/null && echo "‚úÖ Docker Engine" || echo "‚ùå Docker Engine")
            $(systemctl is-enabled mariadb >/dev/null 2>&1 && echo "‚úÖ MariaDB Database" || echo "‚ùå MariaDB Database")
            $(command -v bt >/dev/null && echo "‚úÖ Aapanel Control Panel" || echo "‚ùå Aapanel Control Panel")
            $(command -v tailscale >/dev/null && echo "‚úÖ Tailscale VPN" || echo "‚ùå Tailscale VPN")
            $(command -v tmate >/dev/null && echo "‚úÖ tmate Remote Access" || echo "‚ùå tmate Remote Access")
            $(command -v rclone >/dev/null && echo "‚úÖ Rclone Cloud Storage" || echo "‚ùå Rclone Cloud Storage")
          
          üí° Next Session:
            - Will automatically start in ~6 hours (if scheduled)
            - Can be manually triggered from Actions tab
            - Will restore from backup created in this session
            - Use 'force_fresh_install' to start clean if needed
          
          ==========================================
          EOF
          
          echo "report_generated=true" >> $GITHUB_OUTPUT

      - name: 'üìã Display Final Session Summary'
        if: always()
        run: |
          set -euo pipefail
          
          if [[ -f "/tmp/session_report.txt" ]]; then
            echo ""
            cat /tmp/session_report.txt
            echo ""
          fi
          
          echo "=============================================="
          echo "üèÅ SESSION COMPLETED SUCCESSFULLY"
          echo "=============================================="
          echo ""
          echo "‚ú® Key Achievements:"
          echo "  ‚Ä¢ VPS environment maintained for ${{ steps.init.outputs.duration_minutes || 'planned' }} minutes"
          echo "  ‚Ä¢ System state preserved through comprehensive backup"
          echo "  ‚Ä¢ Remote access configured (Tailscale + tmate)"
          echo "  ‚Ä¢ All critical services installed and running"
          echo "  ‚Ä¢ Automatic restoration capability established"
          echo ""
          echo "üîÑ Continuous Operation:"
          echo "  ‚Ä¢ Next session will auto-start in ~6 hours"
          echo "  ‚Ä¢ Previous state will be automatically restored"
          echo "  ‚Ä¢ Manual triggers available via Actions tab"
          echo ""
          echo "üìû Support & Troubleshooting:"
          echo "  ‚Ä¢ Check workflow logs for detailed information"
          echo "  ‚Ä¢ Use 'force_fresh_install' if restoration fails"
          echo "  ‚Ä¢ Ensure all required secrets are configured"
          echo ""
          echo "üéØ Status: ${{ job.status || 'COMPLETED' }}"
          echo "üïê End Time: $(date -Iseconds)"
          echo "=============================================="

      # ================================================================
      # PHASE 8: ERROR HANDLING & NOTIFICATIONS
      # ================================================================

      - name: 'üö® Handle Workflow Failures'
        if: failure()
        run: |
          set -euo pipefail
          echo "üö® WORKFLOW FAILURE DETECTED"
          echo "=============================================="
          echo ""
          echo "‚ùå The VPS session encountered an error and could not complete successfully."
          echo ""
          echo "üîç Common Issues & Solutions:"
          echo ""
          echo "1. Missing Secrets:"
          echo "   ‚Ä¢ RCLONE_CONFIG: Required for backup storage"
          echo "   ‚Ä¢ USER_PASSWORD: Required for VPS user account"
          echo "   ‚Ä¢ TAILSCALE_AUTHKEY: Required for VPN access"
          echo ""
          echo "2. Backup/Restoration Issues:"
          echo "   ‚Ä¢ Try running with 'force_fresh_install: true'"
          echo "   ‚Ä¢ Check MEGA storage connectivity"
          echo "   ‚Ä¢ Verify GitHub artifact retention"
          echo ""
          echo "3. Service Startup Problems:"
          echo "   ‚Ä¢ Some services may fail on first install"
          echo "   ‚Ä¢ Check individual service logs"
          echo "   ‚Ä¢ Services often work after restoration"
          echo ""
          echo "4. Resource Limitations:"
          echo "   ‚Ä¢ GitHub runners have limited resources"
          echo "   ‚Ä¢ Large backups may cause timeouts"
          echo "   ‚Ä¢ Consider reducing backup scope"
          echo ""
          echo "üí° Next Steps:"
          echo "   ‚Ä¢ Review the workflow logs above"
          echo "   ‚Ä¢ Check your GitHub Secrets configuration"
          echo "   ‚Ä¢ Try manual trigger with fresh install"
          echo "   ‚Ä¢ Wait for automatic retry in 6 hours"
          echo ""
          echo "=============================================="
          
          # Try to create a minimal backup even on failure
          if [[ -d "/home" || -d "/etc" ]]; then
            echo "üÜò Attempting emergency backup of critical data..."
            sudo mkdir -p "${{ env.BACKUP_STORE }}" || true
            sudo tar -czf "${{ env.BACKUP_STORE }}/emergency-backup.tar.gz" \
              /home /etc /var/lib/mysql /var/lib/docker 2>/dev/null || true
            echo "Emergency backup attempt completed (may be partial)"
          fi

      - name: '‚úÖ Workflow Success Confirmation'
        if: success()
        run: |
          echo "‚úÖ PERSISTENT VPS WORKFLOW COMPLETED SUCCESSFULLY!"
          echo ""
          echo "üéâ All phases completed without errors:"
          echo "  ‚úÖ System initialization and tool installation"
          echo "  ‚úÖ Backup detection and restoration (if available)"
          echo "  ‚úÖ User account and service configuration"
          echo "  ‚úÖ Remote access setup (Tailscale + tmate)"
          echo "  ‚úÖ VPS session maintenance"
          echo "  ‚úÖ Comprehensive backup creation"
          echo "  ‚úÖ Cloud storage integration"
          echo ""
          echo "üîÑ The persistent VPS system is now fully operational!"
          echo "üìÖ Next automatic session: $(date -d '+6 hours' -Iseconds)"
