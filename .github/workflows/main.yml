name: Persistent VPS

on:
  schedule:
    # Runs automatically every 6 hours to refresh the session.
    - cron: '0 */6 * * *'
  workflow_dispatch:
    # Allows for manual triggering of the workflow from the Actions tab.

env:
  # Configuration for the backup archive.
  BACKUP_STORE: /var/backups/vps
  BACKUP_NAME: vps-backup-latest.tar.gz
  # Rclone remote and path for cloud storage.
  MEGA_REMOTE: mega:vps-backup

jobs:
  vps:
    runs-on: ubuntu-22.04
    # Set a generous timeout. GitHub Actions max is 6 hours (360 minutes).
    timeout-minutes: 350
    permissions:
      contents: read
      actions: write

    steps:
      - name: 'üï∏Ô∏è Checkout Code'
        uses: actions/checkout@v4

      # ------------------------------------------------------------------
      # Part 1: Initial Setup & Restore Logic
      # ------------------------------------------------------------------

      - name: 'üîß Install Core Tools (One-Time Setup)'
        run: |
          set -euo pipefail
          echo "üåê Updating package list..."
          sudo apt-get update -qq

          echo "üê≥ Installing Docker from official script..."
          curl -fsSL https://get.docker.com | sudo sh

          echo "‚òÅÔ∏è Installing Rclone from official script..."
          curl -fsSL https://rclone.org/install.sh | sudo bash
          
          echo "üì¶ Installing other necessary system tools..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            tar gzip psmisc screen openssh-server mariadb-server \
            mariadb-client wget unzip htop nano vim git net-tools tmate jq \
            curl software-properties-common apt-transport-https ca-certificates \
            gnupg lsb-release
          
          echo "‚úÖ All required tools are installed."

      - name: 'üõ†Ô∏è Configure Rclone'
        run: |
          set -euo pipefail
          echo "üîê Setting up rclone configuration from secrets..."
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "‚ùå ERROR: RCLONE_CONFIG secret is missing or empty!" >&2
            exit 1
          fi
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          echo "‚úÖ Rclone configured successfully."

      - name: '‚ôªÔ∏è Check for Existing Backup'
        id: check_backup
        run: |
          set -euo pipefail
          echo "üîé Checking for existing backup..."

          # Method 1: Try to get the artifact link from MEGA
          if rclone ls "${MEGA_REMOTE}/latest_backup_link.txt" >/dev/null 2>&1; then
              ARTIFACT_LINK=$(rclone cat "${MEGA_REMOTE}/latest_backup_link.txt")
              echo "‚úÖ Backup link found in MEGA!"
              echo "backup_method=mega_link" >> $GITHUB_OUTPUT
              echo "artifact_url=${ARTIFACT_LINK}" >> $GITHUB_OUTPUT
              echo "is_new_install=false" >> $GITHUB_OUTPUT
          else
              # Method 2: Try to find recent artifacts from this repository
              echo "üîç No MEGA link found. Searching for recent artifacts..."
              
              # Get the most recent successful workflow run with artifacts
              RECENT_RUN=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/workflows/persistent-vps.yml/runs?status=success&per_page=5" \
                | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id' | head -1)
              
              if [[ -n "$RECENT_RUN" && "$RECENT_RUN" != "null" ]]; then
                echo "üîç Found recent run: $RECENT_RUN"
                
                # Check if this run has our backup artifact
                ARTIFACT_EXISTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RECENT_RUN}/artifacts" \
                  | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')
                
                if [[ -n "$ARTIFACT_EXISTS" && "$ARTIFACT_EXISTS" != "null" ]]; then
                  ARTIFACT_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_EXISTS}/zip"
                  echo "‚úÖ Found backup artifact in recent run!"
                  echo "backup_method=github_artifact" >> $GITHUB_OUTPUT
                  echo "artifact_url=${ARTIFACT_URL}" >> $GITHUB_OUTPUT
                  echo "run_id=${RECENT_RUN}" >> $GITHUB_OUTPUT
                  echo "is_new_install=false" >> $GITHUB_OUTPUT
                else
                  echo "‚ÑπÔ∏è No backup artifacts found. Fresh installation."
                  echo "is_new_install=true" >> $GITHUB_OUTPUT
                fi
              else
                echo "‚ÑπÔ∏è No recent successful runs found. Fresh installation."
                echo "is_new_install=true" >> $GITHUB_OUTPUT
              fi
          fi

      - name: 'üì• Download Backup from MEGA Link'
        if: steps.check_backup.outputs.is_new_install == 'false' && steps.check_backup.outputs.backup_method == 'mega_link'
        run: |
          set -euo pipefail
          echo "üì• Downloading backup using MEGA artifact link..."
          
          mkdir -p /tmp/restore
          
          # Download the artifact zip using the GitHub API
          curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${{ steps.check_backup.outputs.artifact_url }}" \
            -o "/tmp/restore/${{ env.BACKUP_NAME }}.zip"
          
          # Extract the zip to get the original tarball
          cd /tmp/restore
          unzip -q "${{ env.BACKUP_NAME }}.zip"
          
          echo "‚úÖ Backup downloaded successfully from MEGA link."

      - name: 'üì• Download Backup from GitHub Artifact'
        if: steps.check_backup.outputs.is_new_install == 'false' && steps.check_backup.outputs.backup_method == 'github_artifact'
        run: |
          set -euo pipefail
          echo "üì• Downloading backup from GitHub artifact..."
          
          mkdir -p /tmp/restore
          
          # Download the artifact zip directly
          curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "${{ steps.check_backup.outputs.artifact_url }}" \
            -o "/tmp/restore/${{ env.BACKUP_NAME }}.zip"
          
          # Extract the zip to get the original tarball
          cd /tmp/restore
          unzip -q "${{ env.BACKUP_NAME }}.zip"
          
          echo "‚úÖ Backup downloaded successfully from GitHub artifact."

      - name: 'üìÇ Restore from Downloaded Backup'
        if: steps.check_backup.outputs.is_new_install == 'false'
        run: |
          set -euo pipefail
          echo "üìÇ Restoring system state from downloaded backup..."
          
          # Verify the backup file exists
          if [[ ! -f "/tmp/restore/${{ env.BACKUP_NAME }}" ]]; then
            echo "‚ùå ERROR: Backup file not found after download!"
            echo "Available files in /tmp/restore:"
            ls -la /tmp/restore/ || true
            exit 1
          fi
          
          # Test the backup integrity before restoration
          echo "üß™ Testing backup integrity..."
          if ! sudo tar -tzf "/tmp/restore/${{ env.BACKUP_NAME }}" >/dev/null 2>&1; then
            echo "‚ùå ERROR: Backup archive is corrupted!"
            exit 1
          fi
          
          # Restore the backup
          echo "üìÇ Extracting backup to restore system state..."
          sudo tar -xzpf "/tmp/restore/${{ env.BACKUP_NAME }}" -C / \
            --warning=no-timestamp \
            --exclude='*/lost+found' \
            --exclude='*/proc/*' \
            --exclude='*/sys/*' \
            --exclude='*/dev/*' \
            --exclude='*/run/*' \
            --exclude='*/tmp/*' || true
          
          echo "‚úÖ System restore complete."

      # ------------------------------------------------------------------
      # Part 2: Fresh Installation Steps (Conditional)
      # ------------------------------------------------------------------

      - name: 'üóÑÔ∏è Configure MariaDB (Fresh Install Only)'
        if: steps.check_backup.outputs.is_new_install == 'true'
        run: |
          set -euo pipefail
          echo "üóÑÔ∏è Performing fresh configuration of MariaDB..."
          sudo systemctl enable mariadb
          sudo systemctl start mariadb
          
          # Wait for MariaDB to be ready
          sleep 10
          
          echo "üîí Securing MariaDB installation..."
          if [[ -z "${{ secrets.DB_ROOT_PASSWORD || '' }}" ]]; then
             echo "‚ùå ERROR: DB_ROOT_PASSWORD secret is not set for fresh install!" >&2
             exit 1
          fi
          
          # Secure MariaDB installation
          sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD('${{ secrets.DB_ROOT_PASSWORD }}');" || true
          sudo mysql -u root -p'${{ secrets.DB_ROOT_PASSWORD }}' -e "DELETE FROM mysql.user WHERE User='';" || true
          sudo mysql -u root -p'${{ secrets.DB_ROOT_PASSWORD }}' -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');" || true
          sudo mysql -u root -p'${{ secrets.DB_ROOT_PASSWORD }}' -e "DROP DATABASE IF EXISTS test;" || true
          sudo mysql -u root -p'${{ secrets.DB_ROOT_PASSWORD }}' -e "FLUSH PRIVILEGES;" || true
          echo "‚úÖ MariaDB security configuration complete."

      - name: 'üë§ Initial User & Hostname Setup (Fresh Install Only)'
        if: steps.check_backup.outputs.is_new_install == 'true'
        run: |
          set -euo pipefail
          echo "üë§ Setting up user, password, and hostname..."
          
          # Ensure required secrets exist
          if [[ -z "${{ secrets.USER_PASSWORD || '' }}" ]]; then
            echo "‚ùå ERROR: USER_PASSWORD secret is not set!" >&2
            exit 1
          fi
          
          sudo useradd -m -s /bin/bash jacky || echo "User 'jacky' already exists, skipping."
          echo "jacky:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
          sudo usermod -aG sudo,docker jacky
          echo "jacky ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/jacky
          sudo hostnamectl set-hostname github-vps
          echo "127.0.1.1 github-vps" | sudo tee -a /etc/hosts
          echo "‚úÖ System user and hostname configured."

      - name: 'üì¶ Install Aapanel (Fresh Install Only)'
        if: steps.check_backup.outputs.is_new_install == 'true'
        run: |
          set -euo pipefail
          echo "üì• Downloading and installing Aapanel..."
          
          # Download the install script
          curl -fsSL -o /tmp/install.sh "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"
          
          # Make the script executable
          chmod +x /tmp/install.sh
          
          # Install Aapanel with timeout and proper input handling
          timeout 900 bash -c "printf 'y\nyes\n' | sudo bash /tmp/install.sh" || {
            echo "‚ö†Ô∏è Aapanel installation timed out or failed. Continuing..."
            # Don't exit here, continue with the workflow
          }
          
          # Wait a bit for services to settle
          sleep 10
          
          # Configure Aapanel if it was installed successfully
          if command -v bt >/dev/null 2>&1; then
            echo "‚úÖ Aapanel installed. Setting default credentials..."
            echo "Jacky" | sudo bt 6 || true
            echo "spidey" | sudo bt 5 || true
          else
            echo "‚ÑπÔ∏è Aapanel installation may have failed, but continuing..."
          fi

      # ------------------------------------------------------------------
      # Part 3: Service Start & Session (Runs on every execution)
      # ------------------------------------------------------------------

      - name: 'üöÄ Start All Services'
        run: |
          set -euo pipefail
          echo "üîÑ Configuring and starting all system services..."
          
          echo "Reloading systemd manager configuration..."
          sudo systemctl daemon-reload
          
          # Enable services
          sudo systemctl enable ssh docker
          
          # Start core services
          sudo systemctl start ssh || echo "‚ö†Ô∏è SSH failed to start"
          sudo systemctl start docker || echo "‚ö†Ô∏è Docker failed to start"
          
          # Start MariaDB (may already be running from restore)
          sudo systemctl enable mariadb || true
          sudo systemctl start mariadb || echo "‚ö†Ô∏è MariaDB failed to start"
          
          # Start Aapanel if available
          if command -v bt >/dev/null 2>&1; then
            echo "üéõÔ∏è Starting Aapanel..."
            sudo bt start || echo "‚ö†Ô∏è Aapanel failed to start"
          fi
          
          # Wait for services to be ready
          sleep 5
          
          echo "üìä Final Service Status Check:"
          for service in ssh docker mariadb; do
            if systemctl is-active --quiet $service 2>/dev/null; then
              echo "  ‚úÖ $service is active."
            else
              echo "  ‚ùå $service is INACTIVE or not installed."
            fi
          done

      - name: 'üîó Configure Remote Access (Tailscale & tmate)'
        run: |
          set -euo pipefail
          echo "üï∏Ô∏è Setting up Tailscale VPN for secure access..."
          
          if [[ -z "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
            echo "‚ùå ERROR: TAILSCALE_AUTHKEY secret is missing!" >&2
            exit 1
          fi
          
          # Install Tailscale
          curl -fsSL https://tailscale.com/install.sh | sh
          sudo systemctl enable --now tailscaled
          
          # Connect to Tailscale with retry logic
          for i in {1..3}; do
            if sudo tailscale up --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" --hostname=github-vps --reset --accept-routes; then
              break
            else
              echo "‚ö†Ô∏è Tailscale connection attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          echo "üí¨ Starting tmate for emergency SSH access..."
          tmate -S /tmp/tmate.sock new-session -d || echo "‚ö†Ô∏è tmate failed to start"
          
          # Wait for tmate to be ready
          for i in {1..30}; do
            if tmate -S /tmp/tmate.sock wait tmate-ready 2>/dev/null; then
              break
            fi
            sleep 2
          done
          
          echo "================================================"
          echo "üéâ          VPS IS READY FOR CONNECTION         üéâ"
          echo "================================================"
          
          # Get connection details
          TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null || echo "Not available")
          echo "üåê Tailscale IP: $TAILSCALE_IP"
          
          TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo "Not available")
          echo "üîë tmate SSH:    $TMATE_SSH"
          
          # Show Aapanel info if available
          if command -v bt >/dev/null 2>&1; then
            echo ""
            echo "üéõÔ∏è Aapanel Panel Details:"
            sudo bt default 2>/dev/null || echo "Aapanel info not available"
          fi
          echo "================================================"

      - name: '‚è≥ Maintain VPS Session'
        run: |
          echo "üñ•Ô∏è VPS session is running. This step will time out after ~5.5 hours."
          echo "To stop the session gracefully and trigger the backup early, create a file: touch /tmp/stop"
          echo "Current time: $(date)"
          
          # Calculate end time (5.5 hours = 19800 seconds)
          end_time=$((SECONDS + 19800))
          
          while [ $SECONDS -lt $end_time ]; do
            # Check for graceful shutdown signal
            if [ -f "/tmp/stop" ]; then
              echo "‚úÖ Graceful shutdown signal detected. Exiting session."
              rm -f "/tmp/stop"
              exit 0
            fi
            
            # Show some activity every 10 minutes
            if [ $((SECONDS % 600)) -eq 0 ]; then
              echo "üîÑ Session active - $(date) - Time remaining: $(((end_time - SECONDS) / 60)) minutes"
            fi
            
            sleep 60
          done
          
          echo "‚è∞ Session duration reached. Proceeding to backup."

      # ------------------------------------------------------------------
      # Part 4: Backup Creation (Always runs at the end)
      # ------------------------------------------------------------------
      - name: 'üì¶ Create Full System Backup'
        if: always()
        run: |
          set -euo pipefail
          echo "üì¶ Creating comprehensive system backup..."
          sudo mkdir -p "${{ env.BACKUP_STORE }}"
          
          # Ensure all backup paths exist to prevent tar errors
          sudo mkdir -p /etc/ /home/ /root/ /var/lib/docker/ /var/lib/mysql/ /var/www/ \
                       /var/spool/cron/ /var/lib/dpkg/ /var/lib/tailscale/ /opt/ /srv/ /www/
          
          echo "üõë Stopping services for a clean, consistent backup..."
          if command -v bt >/dev/null 2>&1; then 
            sudo bt stop || echo "‚ö†Ô∏è Aapanel stop failed"
          fi
          
          # Stop services gracefully
          sudo systemctl stop ssh || true
          sudo systemctl stop mariadb || true
          sudo systemctl stop tailscaled || true
          sudo systemctl stop docker || true
          
          # Wait for services to stop
          sleep 10
          
          # Define backup paths
          BACKUP_PATHS="
            /etc/
            /home/
            /root/
            /var/lib/docker/
            /var/lib/mysql/
            /var/www/
            /var/spool/cron/
            /var/lib/dpkg/
            /var/lib/tailscale/
            /opt/
            /srv/
            /www/
          "
          
          # Create backup with better error handling
          echo "Creating optimized backup archive..."
          sudo tar -czpf "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" \
            --absolute-names \
            --warning=no-file-changed \
            --warning=no-file-removed \
            --exclude='*.log*' --exclude='*.pid' --exclude='*.sock' \
            --exclude='*/lost+found' --exclude='*/proc/*' --exclude='*/sys/*' \
            --exclude='*/dev/*' --exclude='*/run/*' --exclude='*/tmp/*' \
            --exclude='*/var/cache/*' --exclude='*/var/tmp/*' \
            $BACKUP_PATHS || {
            echo "‚ö†Ô∏è Backup creation had some warnings, but continuing..."
          }
          
          # Verify backup was created
          if [[ -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" ]]; then
            BACKUP_SIZE=$(du -h "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}" | cut -f1)
            echo "‚úÖ Backup created successfully. Size: $BACKUP_SIZE"
          else
            echo "‚ùå ERROR: Backup file was not created!"
            exit 1
          fi

      - name: '‚¨ÜÔ∏è Upload Backup to GitHub Artifacts'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: ${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}
          retention-days: 7
          if-no-files-found: error

      - name: 'üîó Get Artifact Direct Link and Upload to MEGA'
        if: always()
        run: |
          set -euo pipefail
          echo "üîó Getting direct link for the uploaded artifact..."

          # Wait a bit for the artifact to be processed
          sleep 30

          # Get the artifact ID with retry logic
          for i in {1..5}; do
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[] | select(.name == "${{ env.BACKUP_NAME }}") | .id')

            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
              break
            fi
            
            echo "‚è≥ Waiting for artifact to be available (attempt $i/5)..."
            sleep 30
          done

          if [[ -z "$ARTIFACT_ID" || "$ARTIFACT_ID" == "null" ]]; then
            echo "‚ùå ERROR: Could not get artifact ID!"
            exit 1
          fi

          ARTIFACT_LINK="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
          echo "üìé Artifact link: $ARTIFACT_LINK"

          echo "üóëÔ∏è Removing old link file from MEGA..."
          rclone delete "${MEGA_REMOTE}/latest_backup_link.txt" || echo "No old link file to remove, proceeding."

          echo "üì§ Uploading new artifact link to MEGA..."
          echo "$ARTIFACT_LINK" | rclone rcat "${MEGA_REMOTE}/latest_backup_link.txt"

          echo "‚úÖ Link upload complete."
          
          # Clean up local backup file
          sudo rm -f "${{ env.BACKUP_STORE }}/${{ env.BACKUP_NAME }}"

      - name: 'üìã Final Status Report'
        if: always()
        run: |
          echo "============================================="
          echo "         ‚úÖ VPS SESSION COMPLETE ‚úÖ"
          echo "============================================="
          echo "Job Status: ${{ job.status }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Completion Time: $(date)"
          
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "‚úÖ The session completed normally and the backup was successful."
          else
            echo "‚ö†Ô∏è The session failed or was cancelled. A backup was still attempted."
          fi
          
          echo ""
          echo "üìä Session Statistics:"
          echo "- New Install: ${{ steps.check_backup.outputs.is_new_install }}"
          if [[ "${{ steps.check_backup.outputs.is_new_install }}" == "false" ]]; then
            echo "- Backup Method: ${{ steps.check_backup.outputs.backup_method }}"
          fi
          echo "- Runtime: $((SECONDS / 60)) minutes"
          echo "============================================="
