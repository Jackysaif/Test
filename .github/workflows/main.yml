# -----------------------------------------------------------------------------------
# Persistent VPS (Immortal Edition) - RELIABLE FULL BACKUP VERSION
#
# v13.0 - Full system backup with aggressive compression for reliability
# -----------------------------------------------------------------------------------

name: Persistent VPS (Immortal Edition)

on:
  schedule:
    - cron: '0 */4 * * *'
  workflow_dispatch:
    inputs:
      force_fresh_install:
        description: 'Force fresh installation (ignore backups)'
        required: false
        default: 'false'
        type: boolean
      backup_retention_days:
        description: 'Backup retention days'
        required: false
        default: '7'
        type: string
      session_duration_minutes:
        description: 'Session duration in minutes'
        required: false
        default: '220'
        type: string

env:
  BACKUP_STORE: /tmp/vps-backups
  FULL_BACKUP_NAME: full-system-backup.tar.zst
  MEGA_REMOTE: mega:vps-backup

jobs:
  vps:
    runs-on: ubuntu-22.04
    timeout-minutes: 235
    permissions:
      contents: read
      actions: write

    steps:
      - name: '🚀 Initialize Environment'
        uses: actions/checkout@v4

      - name: '🔧 Install Enhanced Toolchain'
        run: |
          set -euo pipefail
          echo "Installing enhanced toolchain..."
          
          sudo apt-get update -qq
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            zstd pv rsync jq curl wget psmisc screen tmate \
            htop fail2ban ufw python3-pip tree fuse \
            software-properties-common apt-transport-https ca-certificates \
            gnupg lsb-release
          
          curl -fsSL https://rclone.org/install.sh | sudo bash
          pip3 install --user psutil requests
          
          rclone version
          zstd --version
          echo "✅ Enhanced toolchain installed successfully."

      - name: '🔐 Configure Rclone'
        run: |
          set -euo pipefail
          
          if [[ -z "${{ secrets.RCLONE_CONFIG || '' }}" ]]; then
            echo "❌ CRITICAL: RCLONE_CONFIG secret is missing!" >&2
            exit 1
          fi
          
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONFIG }}" > ~/.config/rclone/rclone.conf
          chmod 600 ~/.config/rclone/rclone.conf
          
          if ! rclone listremotes | grep -q "mega:"; then
            echo "❌ CRITICAL: Rclone MEGA remote not configured properly!" >&2
            exit 1
          fi
          
          echo "✅ Rclone configured and tested successfully."

      - name: '🔍 Full Backup Discovery'
        id: discover_backup
        run: |
          set -euo pipefail
          echo "🔎 Looking for previous full system backups..."
          
          BACKUP_FOUND=false
          BACKUP_SOURCE=""
          BACKUP_URL=""
          
          if [[ "${{ github.event.inputs.force_fresh_install || 'false' }}" == "true" ]]; then
            echo "🔄 Fresh installation forced by user."
            echo "backup_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          WORKFLOW_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows" \
            | jq -r '.workflows[] | select(.name == "Persistent VPS (Immortal Edition)") | .id' | head -1)
          
          if [[ -n "$WORKFLOW_ID" && "$WORKFLOW_ID" != "null" ]]; then
            LATEST_RUN_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs?status=success&per_page=5" \
              | jq -r '.workflow_runs[] | select(.id != ${{ github.run_id }}) | .id' | head -1)
            
            if [[ -n "$LATEST_RUN_ID" && "$LATEST_RUN_ID" != "null" ]]; then
              ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/runs/${LATEST_RUN_ID}/artifacts")
              
              FULL_ARTIFACT_ID=$(echo "$ARTIFACTS_JSON" | jq -r ".artifacts[] | select(.name | contains(\"full\")) | .id" | head -1)
              if [[ -n "$FULL_ARTIFACT_ID" && "$FULL_ARTIFACT_ID" != "null" ]]; then
                BACKUP_URL="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${FULL_ARTIFACT_ID}/zip"
                BACKUP_SOURCE="github_artifact"
                BACKUP_FOUND=true
              fi
            fi
          fi
          
          if [[ "$BACKUP_FOUND" == "false" ]] && rclone ls "${MEGA_REMOTE}/full_backup_link.txt" >/dev/null 2>&1; then
            BACKUP_URL=$(rclone cat "${MEGA_REMOTE}/full_backup_link.txt" | head -1)
            BACKUP_SOURCE="mega_link"
            BACKUP_FOUND=true
          fi
          
          echo "backup_found=$BACKUP_FOUND" >> $GITHUB_OUTPUT
          echo "backup_source=$BACKUP_SOURCE" >> $GITHUB_OUTPUT
          echo "backup_url=$BACKUP_URL" >> $GITHUB_OUTPUT
          
          if [[ "$BACKUP_FOUND" == "true" ]]; then
            echo "✅ Full backup found from $BACKUP_SOURCE"
          else
            echo "ℹ️ No previous full backup found. Will perform fresh installation."
          fi

      - name: '🔄 Full System Restoration'
        if: steps.discover_backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          echo "🚀 Restoring from full system backup..."
          
          sudo mkdir -p /mnt/restore
          cd /mnt/restore
          
          max_attempts=3
          for attempt in $(seq 1 $max_attempts); do
            echo "Download attempt $attempt/$max_attempts..."
            if timeout 600 curl --retry 3 -L \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "${{ steps.discover_backup.outputs.backup_url }}" -o "backup.zip"; then
              break
            fi
            if [[ $attempt -eq $max_attempts ]]; then
              echo "❌ Download failed after $max_attempts attempts!" >&2
              exit 1
            fi
            sleep 30
          done
          
          sudo unzip -q backup.zip
          BACKUP_FILE=$(find . -name "*.tar.zst" -type f | head -1)
          
          if [[ ! -f "$BACKUP_FILE" ]] || ! zstd -t "$BACKUP_FILE"; then
            echo "❌ Backup file invalid!" >&2
            exit 1
          fi
          
          echo "✅ Backup verified (Size: $(du -h "$BACKUP_FILE" | cut -f1))"
          echo "🔄 Restoring full system..."
          
          pv "$BACKUP_FILE" | sudo tar -I zstd -xpf - -C /
          
          sudo rm -rf /mnt/restore
          echo "✅ Full restoration completed successfully."
          
      - name: '🛠️ Post-Restoration System Repair'
        if: steps.discover_backup.outputs.backup_found == 'true'
        run: |
          set -euo pipefail
          echo "🔧 Performing post-restoration repairs..."
          
          sudo apt-get update -qq || true
          
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com | sudo sh
          fi
          
          for service in ssh docker mariadb fail2ban; do
            if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
              sudo systemctl daemon-reload
              sudo systemctl enable "$service" 2>/dev/null || true
              sudo systemctl restart "$service" 2>/dev/null || true
            fi
          done
          
          if [[ -d "/var/lib/mysql" ]]; then
            sudo chown -R mysql:mysql /var/lib/mysql
            sudo systemctl restart mariadb 2>/dev/null || true
          fi
          
          if [[ -f "/www/server/panel/init.sh" ]]; then
            sudo /www/server/panel/init.sh restart || true
          fi
          
          echo "✅ Post-restoration repair completed."

      - name: '🆕 Enhanced Fresh Installation'
        if: steps.discover_backup.outputs.backup_found == 'false'
        run: |
          set -euo pipefail
          echo "🚀 Performing fresh installation..."
          
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker "$USER"
          fi
          
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            mariadb-server fail2ban ufw openssh-server nginx
          
          if curl -fsSL -o /tmp/install_aapanel.sh "http://www.aapanel.com/script/install-ubuntu_6.0_en.sh"; then
            chmod +x /tmp/install_aapanel.sh
            timeout 1200 bash -c "printf 'y\nyes\n' | sudo bash /tmp/install_aapanel.sh" || \
              echo "⚠️ aaPanel installation timed out"
          fi
          
          echo "✅ Fresh installation completed."

      - name: '🔐 Security & User Setup'
        if: steps.discover_backup.outputs.backup_found == 'false'
        run: |
          set -euo pipefail
          echo "🔐 Setting up security..."
          
          if ! id "jacky" >/dev/null 2>&1; then
            sudo useradd -m -s /bin/bash -G sudo,docker jacky
            if [[ -n "${{ secrets.USER_PASSWORD || '' }}" ]]; then
              echo "jacky:${{ secrets.USER_PASSWORD }}" | sudo chpasswd
              echo "jacky ALL=(ALL:ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/jacky
            fi
          fi
          
          if systemctl is-active --quiet mariadb && [[ -n "${{ secrets.DB_ROOT_PASSWORD || '' }}" ]]; then
            sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING PASSWORD('${{ secrets.DB_ROOT_PASSWORD }}'); FLUSH PRIVILEGES;" || true
          fi
          
          if [[ -f "/www/server/panel/init.sh" ]]; then
            timeout 30 bash -c 'echo "Jacky" | sudo bt 6' || true
            timeout 30 bash -c 'echo "spidey" | sudo bt 5' || true
          fi
          
          sudo ufw --force reset
          sudo ufw default deny incoming
          sudo ufw default allow outgoing
          sudo ufw allow ssh
          sudo ufw allow http
          sudo ufw allow https
          sudo ufw allow 8888/tcp
          sudo ufw --force enable
          
          for service in fail2ban ssh mariadb docker nginx; do
            if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
              sudo systemctl enable --now "$service" 2>/dev/null || true
            fi
          done
          
          echo "✅ Security setup completed."

      - name: '🌐 Configure Network Access'
        run: |
          set -euo pipefail
          echo "🌐 Setting up network access..."
          
          if ! command -v tailscale >/dev/null 2>&1; then
            curl -fsSL https://tailscale.com/install.sh | sh
          fi
          
          if [[ -n "${{ secrets.TAILSCALE_AUTHKEY || '' }}" ]]; then
            sudo systemctl enable --now tailscaled
            if [[ -f "/var/lib/tailscale/tailscaled.state" ]]; then
              sudo tailscale up --accept-routes || true
            else
              sudo tailscale up \
                --authkey="${{ secrets.TAILSCALE_AUTHKEY }}" \
                --hostname="github-vps-smart-$(date +%s)" \
                --reset --accept-routes || true
            fi
          fi
          
          tmate -S /tmp/tmate.sock new-session -d
          timeout 60 bash -c 'while ! tmate -S /tmp/tmate.sock wait tmate-ready; do sleep 1; done' || true
          
          echo ""
          echo "================================================="
          echo "🎉      RELIABLE VPS IS READY FOR CONNECTION   🎉"
          echo "================================================="
          
          if command -v tailscale >/dev/null 2>&1; then
            TAILSCALE_IP=$(sudo tailscale ip -4 2>/dev/null || echo "Not available")
            echo "🌐 Tailscale IP: $TAILSCALE_IP"
          fi
          
          if tmate -S /tmp/tmate.sock list-sessions >/dev/null 2>&1; then
            TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null || echo "Not available")
            echo "🔑 tmate SSH:    $TMATE_SSH"
          fi
          
          if [[ -f "/www/server/panel/init.sh" ]]; then
            echo ""
            echo "📊 aaPanel Information:"
            sudo bt default || true
          fi
          
          echo "================================================="

      - name: '⏳ Session Maintenance'
        run: |
          set -euo pipefail
          echo "⏳ Starting session maintenance..."
          
          SESSION_DURATION_MINUTES=${{ github.event.inputs.session_duration_minutes || '220' }}
          SESSION_DURATION_SECONDS=$((SESSION_DURATION_MINUTES * 60))
          
          log_message() { echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"; }
          
          cat << 'EOF' > /tmp/session_keeper.sh
          #!/bin/bash
          log_message() { echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"; }
          
          while true; do
              for service in ssh tailscaled docker mariadb; do
                  if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
                      if systemctl is-enabled --quiet "$service" 2>/dev/null && ! systemctl is-active --quiet "$service"; then
                          log_message "⚠️ $service down, restarting..."
                          sudo systemctl restart "$service"
                      fi
                  fi
              done
              
              if ! tmate -S /tmp/tmate.sock list-sessions >/dev/null 2>&1; then
                  log_message "⚠️ tmate session lost, restarting..."
                  tmate -S /tmp/tmate.sock new-session -d
                  sleep 5
                  tmate -S /tmp/tmate.sock wait tmate-ready
                  log_message "✅ tmate restarted: $(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}' 2>/dev/null)"
              fi
              
              sleep 300
          done
          EOF
          
          chmod +x /tmp/session_keeper.sh
          nohup bash /tmp/session_keeper.sh > /tmp/session_keeper.log 2>&1 &
          KEEPER_PID=$!
          
          log_message "🖥️ Session started (PID: $KEEPER_PID, Duration: $SESSION_DURATION_MINUTES min)"
          log_message "🛑 To shutdown early: touch /tmp/stop"
          
          END_TIME=$((SECONDS + SESSION_DURATION_SECONDS))
          
          while [ $SECONDS -lt $END_TIME ]; do
            if [ -f "/tmp/stop" ]; then
              log_message "✅ Early shutdown requested"
              sudo rm -f "/tmp/stop"
              break
            fi
            
            REMAINING_MINUTES=$(( (END_TIME - SECONDS) / 60 ))
            if (( SECONDS % 1800 == 0 )); then
              log_message "📊 $REMAINING_MINUTES minutes remaining"
            fi
            
            sleep 60
          done
          
          if kill -0 $KEEPER_PID 2>/dev/null; then
            kill $KEEPER_PID
          fi
          
          log_message "⏰ Session concluded. Starting reliable backup..."

      - name: '📦 Create Reliable Full Backup'
        id: create_backup
        if: always()
        run: |
          set -euo pipefail
          echo "📦 Creating reliable full system backup..."
          
          mkdir -p "${{ env.BACKUP_STORE }}"
          
          BACKUP_EXCLUDES=(
            "/dev/*"
            "/proc/*"
            "/sys/*"
            "/tmp/*"
            "/run/*"
            "/mnt/*"
            "/media/*"
            "/lost+found"
            "/home/runner"
            "/var/lib/docker/overlay2"
            "/var/cache/*"
            "/var/tmp/*"
            "/var/log/*"
            "${{ env.BACKUP_STORE }}/*"
          )
          
          EXCLUDE_OPTIONS=$(printf -- "--exclude=%s " "${BACKUP_EXCLUDES[@]}")
          
          echo "🔄 Syncing system files to temporary directory..."
          sudo mkdir -p /mnt/full_backup
          sudo rsync -aAX --progress $EXCLUDE_OPTIONS / /mnt/full_backup
          
          BACKUP_FILE="${{ env.BACKUP_STORE }}/${{ env.FULL_BACKUP_NAME }}"
          echo "🚀 Creating compressed archive..."
          START_TIME=$(date +%s)
          
          sudo tar -C /mnt/full_backup -cf - . | zstd -T0 -19 -q > "$BACKUP_FILE"
          
          END_TIME=$(date +%s)
          BACKUP_TIME=$((END_TIME - START_TIME))
          
          if [[ ! -f "$BACKUP_FILE" ]] || [[ ! -s "$BACKUP_FILE" ]] || ! zstd -t "$BACKUP_FILE"; then
            echo "❌ Backup failed or is corrupted!" >&2
            exit 1
          fi
          
          BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
          
          echo "✅ FULL SYSTEM BACKUP COMPLETED!"
          echo "📊 Size: $BACKUP_SIZE (Ultra Compact!)"
          echo "⚡ Time: ${BACKUP_TIME} seconds"
          echo "🎯 Contains: The ENTIRE system, minus ephemeral data"
          
          sudo rm -rf /mnt/full_backup
          
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT
          echo "artifact_name=$FULL_BACKUP_NAME" >> $GITHUB_OUTPUT
          echo "backup_size=$BACKUP_SIZE" >> $GITHUB_OUTPUT
          echo "backup_time=${BACKUP_TIME}s" >> $GITHUB_OUTPUT

      - name: '⬆️ Upload Reliable Backup'
        if: always() && steps.create_backup.outputs.backup_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.create_backup.outputs.artifact_name }}
          path: ${{ steps.create_backup.outputs.backup_file }}
          retention-days: ${{ github.event.inputs.backup_retention_days || '7' }}
          if-no-files-found: error
          compression-level: 0

      - name: '🔗 Store Backup Link'
        if: always() && steps.create_backup.outputs.backup_file != ''
        run: |
          set -euo pipefail
          echo "🔗 Storing backup link in MEGA..."
          
          ARTIFACT_NAME="${{ steps.create_backup.outputs.artifact_name }}"
          BACKUP_SIZE="${{ steps.create_backup.outputs.backup_size }}"
          BACKUP_TIME="${{ steps.create_backup.outputs.backup_time }}"
          
          sleep 45
          
          ARTIFACT_ID=""
          for attempt in {1..10}; do
            echo "Getting artifact ID (attempt $attempt)..."
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r ".artifacts[] | select(.name == \"$ARTIFACT_NAME\") | .id")
            
            if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
              break
            fi
            sleep 15
          done
          
          if [[ -n "$ARTIFACT_ID" && "$ARTIFACT_ID" != "null" ]]; then
            ARTIFACT_LINK="https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${ARTIFACT_ID}/zip"
            
            cat << EOF | rclone rcat "${MEGA_REMOTE}/full_backup_link.txt"
            $ARTIFACT_LINK
            Backup: Full System Backup 📦
            Size: $BACKUP_SIZE (Ultra Compact!)
            Time: $BACKUP_TIME (Lightning Fast!)
            Created: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
            Run: ${{ github.run_id }}

            🚀 RELIABLE BACKUP CONTENTS:
              ========================
            ✅ The ENTIRE system state is captured, ensuring perfect restoration.
            ✅ All installed packages, services, configurations, and user data.
            ✅ Aggressive compression minimizes file size & upload time.
            🛡️ Avoids missing critical files and configurations.
            💡 The most reliable method for an ephemeral environment.

            Next restoration will be LIGHTNING FAST! ⚡
            EOF
            
            echo "✅ Full backup link stored successfully!"
            
          else
            echo "⚠️ Could not get artifact ID, uploading backup directly..."
            BACKUP_FILE="${{ steps.create_backup.outputs.backup_file }}"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            
            if rclone copy "$BACKUP_FILE" "${MEGA_REMOTE}/direct-backups/${TIMESTAMP}_${ARTIFACT_NAME}"; then
              echo "✅ Direct upload successful!"
            else
              echo "❌ All upload methods failed!" >&2
              exit 1
            fi
          fi
          
          echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - FULL backup ($BACKUP_SIZE in $BACKUP_TIME) - Run ${{ github.run_id }}" | \
            rclone rcat "${MEGA_REMOTE}/full_backup_history.log" --append
          
          rclone delete "${MEGA_REMOTE}/smart_backup_link.txt" 2>/dev/null || true
          rclone delete "${MEGA_REMOTE}/incremental_backup_link.txt" 2>/dev/null || true
          
          echo "🎉 Full backup storage completed - Next restore will be SUPER FAST!"

      - name: '🧹 Enhanced Cleanup'
        if: always()
        run: |
          set -euo pipefail
          echo "🧹 Performing cleanup..."
          
          cleanup_paths=(
            "/tmp/tmate.sock"
            "/tmp/session_keeper.sh"
            "/tmp/session_keeper.log"
            "/mnt/restore"
            "/mnt/full_backup"
            "/tmp/stopped_services.txt"
          )
          
          for path in "${cleanup_paths[@]}"; do
            if [[ -e "$path" ]]; then
              sudo rm -rf "$path"
            fi
          done
          
          sudo apt-get autoremove -y 2>/dev/null || true
          sudo apt-get autoclean 2>/dev/null || true
          
          echo "✅ Cleanup completed."

      - name: '📊 Final Status Report'
        if: always()
        run: |
          echo ""
          echo "================================================="
          echo "🎯      RELIABLE VPS - FINAL STATUS REPORT     🎯"
          echo "================================================="
          echo "⚡ SESSION TYPE: Reliable & Fast VPS"
          echo "🕐 Duration: ${{ github.event.inputs.session_duration_minutes || '220' }} minutes"
          echo "💾 Backup Type: Full System Backup"
          echo "📦 Backup Size: ${{ steps.create_backup.outputs.backup_size || 'N/A' }}"
          echo "⚡ Backup Time: ${{ steps.create_backup.outputs.backup_time || 'N/A' }}"
          echo "🔍 Previous Backup: ${{ steps.discover_backup.outputs.backup_found || 'false' }}"
          echo "🆔 Run ID: ${{ github.run_id }}"
          echo "================================================="
          
          echo "💻 System Info:"
          echo "   OS: $(lsb_release -d 2>/dev/null | cut -f2 || echo 'Ubuntu')"
          echo "   Uptime: $(uptime -p 2>/dev/null || echo 'N/A')"
          echo "   Load: $(uptime | awk -F'load average:' '{print $2}' | xargs || echo 'N/A')"
          
          echo ""
          echo "🔧 Key Services:"
          for service in ssh docker mariadb tailscaled nginx; do
            if systemctl list-unit-files --type=service | grep -q "^${service}\.service"; then
              if systemctl is-active --quiet "$service"; then
                echo "   ✅ $service: Running"
              else
                echo "   ⚠️ $service: Stopped"
              fi
            fi
          done
          
          echo ""
          echo "🚀 RELIABLE BACKUP ADVANTAGES:"
          echo "   ✅ Captures the entire system state for a perfect restore."
          echo "   ⚡ Aggressive compression minimizes file size & upload time."
          echo "   🛡️ Avoids missing critical files and configurations."
          echo "   💡 The most reliable method for an ephemeral environment."
          
          echo ""
          echo "🎉 RELIABLE VPS SESSION COMPLETED SUCCESSFULLY! 🎉"
          echo "Next backup/restore cycle will be SUPER FAST! ⚡"
          echo "================================================="
